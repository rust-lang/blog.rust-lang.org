---
layout: post
title: "Announcing Rust 1.13.0"
author: The Rust Core Team
---

The Rust team is happy to announce the latest version of Rust, 1.13.0. Rust is
a systems programming language focused on safety, speed, and concurrency.

As always, you can [install Rust 1.13.0][install] from the appropriate page on
our website, and check out the [detailed release notes for 1.13.0][notes] on
GitHub. 1448 patches were landed in this release.

[install]: https://www.rust-lang.org/install.html
[notes]: 

### What's in 1.13.0 stable

The two big things in Rust 1.13 stable are compiler performance and a new
operator, `?`. As usual, there's also a number of library stabilizations and
other minor improvements and changes.

#### The `?` operator

Rust has gained a new operator, `?`, that's used to make error-handling more
pleasant.

Imagine we had some code to read some data from a file:

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("username.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

This code has two paths that can fail, opening the file and reading the
data from it. If either of these fail to work, we'd like to return an
error from `read_username_from_file`. Doing so involves `match`ing on
the result of the I/O operations. While this gives us a lot of control
over the details, in many cases, we just want to propogate any errors
and write the "happy path" code.

With `?`, this code looks like this:

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("username.txt")?;
    let mut s = String::new();

    f.read_to_string(&mut s)?

    Ok(s)
}
```

In other words, `?` applies to a `Result` value, and if it was an `Ok`, it
unwraps it and gives the inner value. If it was an `Err`, it returns from
the function you're currently in.

Seasoned Rustaceans may recongize that this is the same as the `try!` macro
that's been available since Rust `1.0`. And indeed, they are the same. Before
1.13, `read_username_from_file` could have been implemented like this:

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = try!(File::open("username.txt"));
    let mut s = String::new();

    try!(f.read_to_string(&mut s))

    Ok(s)
}
```

So why extend the language when we already have a macro? There are multiple
reasons. The first is that this is the nature of macros: they're a great way to
experiment with an extended Rust syntax without needing to modify the language.
But if a macro is extremely commonly used, that means that the language itself is
missing something important. And indeed, `try!` is one of the most-used macros
in Rust.

> An aside: why is `try!` a macro? If it were a regular function, there's be no
> way to return from the _calling_ function, and so must be a macro.

Secondly, while `try!` does work, it's not always easy to use: it can lead to
poor error messages, and is very ugly when chained together. Consider:

```rust
try!(try!(try!(foo()).bar()).baz())
```

as opposed to

```rust
foo()?.bar()?.baz()?
```

This happens in situations like the builder pattern. As for poor error messages,
if you tried to use `try!` in a function that didn't return a `Result`, like `main`:

```rust
fn main() {
    try!(Ok("lol"));
}
```

You'd get a poor error message:

```text
error[E0308]: mismatched types
 --> foo.rs:2:5
  |
2 |     try!(Ok("lol"));
  |     ^^^^^^^^^^^^^^^^ expected (), found enum `std::result::Result`
  |
  = note: expected type `()`
  = note:    found type `std::result::Result<_, _>`
  = note: this error originates in a macro outside of the current crate
```

In order to make a good diagnostic here, we'd have to special-case `try!`
anyway. While we're [still working on improving the
diagnostic](https://github.com/rust-lang/rust/issues/35946), we now have
the ability to do so.

#### Performance improvements


There has bee a lot of focus on compiler performance lately. There's good news
in this release, and more to come.

Mark Simulacrum and Nick Cameron have been refining [perf.rust-lang.org], our
tool for tracking compiler performance. It runs the [rustc-benchmarks] suite
regularly, on dedicated hardware, and tracks the results over time. This tool
records the results for each pass in the compiler and is used by the compiler
developers to narrow commit ranges of performance regressions. It's an important
part of our toolbox!

We can use this tool to look at a [graph] of performance over the 1.13
development cycle. This cycle covered the dates from August 16 through September
29 (the graph begins from Augest 25th though and is filtered in a few ways to
eliminate bogus, incomplete, or confusing results). There appear to be some big
reductions, which are quantified on the corresponding [statistics] page.

The big improvement demonstrated in the graphs, on September 1, is from an
optimization from Niko to [cache normalized projections during
translation][cache]. That is to say, during generation of LLVM IR, the compiler
no longer recomputes concrete instances of associated types each time they are
needed, but instead reuses previously-computed values. This optimization doesn't
affect all code bases, but in code bases that exhibit certain patterns, like
[futures-rs], where [debug mode build-time improved by up to 40%][ev1], you'll notice
the difference.

Another such optimization, that doesn't affect every crate but does affect some
in a big way, came from Michael Woerister, and improves compile time for crates
that export many [inline] functions. When a function is marked `#[inline]`, in
addition to translating that function for use by the current crate, the compiler
stores its MIR representation in the crate rlib, and translates the function to
LLVM IR in every crate that calls it. The optimization Michael did is obvious in
retrospect: there are some cases where inline functions are only for the
consumption of other crates, and never called from the crate in which they are
defined; so the compiler doesn't need to translate code for inline functions in
the crate they are defined _unless_ they are called directly. This saves the
cost of rustc converting the function to LLVM IR and LLVM optimizing and
converting the function to machine code (TODO is this right about converting to
machine code - were these functions public before?).

In some cases this results in dramatic improvements. Build times for the ndarray
crate [improved by 50%][ev2], and in the (unreleased) [winapi 0.3] crate, which
is nothing but inline functions, rustc now generates the following LLVM IR:

```ll
; ModuleID = 'winapi.cgu-0.rs'
source_filename = "winapi.cgu-0.rs"
target datalayout = "e-m:w-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc"

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4}

!0 = distinct !DICompileUnit(language: DW_LANG_Rust, file: !1, producer: "rustc version 1.13.0-dev (cf976fe2c 2016-09-15)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
!1 = !DIFile(filename: ".\5Csrc\5Clib.rs", directory: "C:\5Cmsys64\5Chome\5CPeter\5Cwinapi-rs")
!2 = !{}
!3 = !{i32 2, !"CodeView", i32 1}
!4 = !{i32 2, !"Debug Info Version", i32 3}
```

You're eyes don't deceive you. This crate contains no code at all, and it's not
going to pay for what it doesn't use.

But wait, there's more still! Nick Nethercote has [turned his focus to compiler
performance as well][speed], focusing on profiling and micro-optimizations. This
release contains [several fruits of his work][fruit], and there are more in the
pipeline for 1.14. And work toward [incremental compilation] continues.

See the [detailed release notes][notes] for more.

[incremental compilation]: https://blog.rust-lang.org/2016/09/08/incremental.html
[fruit]: https://github.com/rust-lang/rust/blob/stable/RELEASES.md#compile-time-optimizations
[speed]: https://blog.mozilla.org/nnethercote/2016/10/14/how-to-speed-up-the-rust-compiler
[winapi 0.3]: https://github.com/retep998/winapi-rs
[ev1]: https://github.com/rust-lang/rust/pull/37600#issuecomment-258696690
[ev2]: https://github.com/rust-lang/rust/pull/37600#issuecomment-258706020
[futures-rs]: https://github.com/alexcrichton/futures-rs
[cache]: https://github.com/rust-lang/rust/pull/35761
[graph]: https://goo.gl/6T69T2
[statistics]: https://goo.gl/CLIAhi
[perf.rust-lang.org]: http://perf.rust-lang.org
[rustc-benchmarks]: https://github.com/rust-lang-nursery/rustc-benchmarks
[inline]: https://github.com/rust-lang/rust/pull/36524

#### Library stabilizations

* [Add `assert_ne!` and `debug_assert_ne!`][35074]
* [Make `vec_deque::Drain`, `hash_map::Drain`, and `hash_set::Drain`
  covariant][35354]
* [Implement `AsRef<[T]>` for `std::slice::Iter`][35559]
* [Implement `Debug` for `std::vec::IntoIter`][35707]
* [`CString`: avoid excessive growth just to 0-terminate][35871]
* [Implement `CoerceUnsized` for `{Cell, RefCell, UnsafeCell}`][35627]
* [Use arc4rand on FreeBSD][35884]
* [memrchr: Correct aligned offset computation][35969]
* [Improve Demangling of Rust Symbols][36059]
* [Use monotonic time in condition variables][35048]
* [Implement `Debug` for `std::path::{Components,Iter}`][36101]
* [Implement conversion traits for `char`][35755]
* [Fix illegal instruction caused by overflow in channel cloning][36104]
* [Zero first byte of CString on drop][36264]
* [Inherit overflow checks for sum and product][36372]
* [Add missing Eq implementations][36423]
* [Implement `Debug` for `DirEntry`][36631]
* [When `getaddrinfo` returns `EAI_SYSTEM` retrieve actual error from
  `errno`][36754]
* [`SipHasher`] is deprecated. Use [`DefaultHasher`].
* [Implement more traits for `std::io::ErrorKind`][35911]
* [Optimize BinaryHeap bounds checking][36072]
* [Work around pointer aliasing issue in `Vec::extend_from_slice`,
  `extend_with_element`][36355]
* [Fix overflow checking in unsigned pow()][34942]

[35074]: https://github.com/rust-lang/rust/pull/35074
[35074]: https://github.com/rust-lang/rust/pull/35074
[35354]: https://github.com/rust-lang/rust/pull/35354
[35559]: https://github.com/rust-lang/rust/pull/35559
[35707]: https://github.com/rust-lang/rust/pull/35707
[35871]: https://github.com/rust-lang/rust/pull/35871
[35627]: https://github.com/rust-lang/rust/pull/35627
[35884]: https://github.com/rust-lang/rust/pull/35884
[35969]: https://github.com/rust-lang/rust/pull/35969
[36059]: https://github.com/rust-lang/rust/pull/36059
[35048]: https://github.com/rust-lang/rust/pull/35048
[36101]: https://github.com/rust-lang/rust/pull/36101
[35755]: https://github.com/rust-lang/rust/pull/35755
[36104]: https://github.com/rust-lang/rust/pull/36104
[36264]: https://github.com/rust-lang/rust/pull/36264
[36372]: https://github.com/rust-lang/rust/pull/36372
[36423]: https://github.com/rust-lang/rust/pull/36423
[36631]: https://github.com/rust-lang/rust/pull/36631
[36754]: https://github.com/rust-lang/rust/pull/36754
[35911]: https://github.com/rust-lang/rust/pull/35911
[36072]: https://github.com/rust-lang/rust/pull/36072
[36355]: https://github.com/rust-lang/rust/pull/36355
[34942]: https://github.com/rust-lang/rust/pull/34942

See the [detailed release notes][notes] for more.

#### Cargo features

This release contains critical security updates to Cargo, which depends on
curl and OpenSSL, which both published critical security updates recently.
For more information see the respective announcements for [curl 7.51.0] and
[OpenSSL 1.0.2j].

[curl 7.51.0]: https://curl.haxx.se/changes.html
[OpenSSL 1.0.2j]: https://www.openssl.org/news/secadv/20160922.txt

* [Update OpenSSL to 1.0.2j][cargo/3121]
* [Update curl and curl-sys][cargo/3241]
* [Add --all-features flag to cargo][cargo/3038]
* [Add license and license_file to cargo metadata output][cargo/3110]
* [Don't download dependencies from other platforms][cargo/3123]
* [Add support for per-target rustflags in .cargo/config][cargo/3157]
* [Avoid updating registry when adding existing deps][cargo/3144]
* [Use workspaces during `cargo install`][cargo/3146]
* [Add --message-format flag][cargo/3000]

[cargo/3021]: https://github.com/rust-lang/cargo/pull/3021
[cargo/3241]: https://github.com/rust-lang/cargo/pull/3241
[cargo/3038]: https://github.com/rust-lang/cargo/pull/3038
[cargo/3110]: https://github.com/rust-lang/cargo/pull/3110
[cargo/3123]: https://github.com/rust-lang/cargo/pull/3123
[cargo/3157]: https://github.com/rust-lang/cargo/pull/3157
[cargo/3144]: https://github.com/rust-lang/cargo/pull/3144
[cargo/3146]: https://github.com/rust-lang/cargo/pull/3146
[cargo/3000]: https://github.com/rust-lang/cargo/pull/3000

See the [detailed release notes][notes] for more.

### Contributors to 1.13.0

We had 155 individuals contribute to 1.13.0. Thank you so much!

* Aaron Gallagher
* Abhishek Kumar
* aclarry
* Adam Medziński
* Ahmed Charles
* Aleksey Kladov
* Alexander von Gluck IV
* Alexandre Oliveira
* Alex Burka
* Alex Crichton
* Amanieu d'Antras
* Amit Levy
* Andrea Corradi
* Andre Bogus
* Andrew Cann
* Andrew Cantino
* Andrew Lygin
* Andrew Paseltiner
* Andy Russell
* Ariel Ben-Yehuda
* arthurprs
* Ashley Williams
* athulappadan
* Austin Hicks
* bors
* Brian Anderson
* c4rlo
* Caleb Jones
* CensoredUsername
* cgswords
* changchun.fan
* Chiu-Hsiang Hsu
* Chris Stankus
* Christopher Serr
* Chris Wong
* clementmiao
* Cobrand
* Corey Farwell
* Cristi Cobzarenco
* crypto-universe
* dangcheng
* Daniele Baracchi
* DarkEld3r
* David Tolnay
* Dustin Bensing
* Eduard Burtescu
* Eduard-Mihai Burtescu
* Eitan Adler
* Erik Uggeldahl
* Esteban Küber
* Eugene Bulkin
* Eugene R Gonzalez
* Fabian Zaiser
* Federico Ravasio
* Felix S. Klock II
* Florian Gilcher
* Gavin Baker
* Georg Brandl
* ggomez
* Gianni Ciccarelli
* Guillaume Gomez
* Jacob
* jacobpadkins
* Jake Goldsborough
* Jake Goulding
* Jakob Demler
* James Duley
* James Miller
* Jared Roesch
* Jared Wyles
* Jeffrey Seyfried
* JessRudder
* Joe Neeman
* Johannes Löthberg
* John Firebaugh
* johnthagen
* Jonas Schievink
* Jonathan Turner
* Jorge Aparicio
* Joseph Dunne
* Josh Triplett
* Justin LeFebvre
* Keegan McAllister
* Keith Yeung
* Keunhong Lee
* king6cong
* Knight
* knight42
* Kylo Ginsberg
* Liigo
* Manish Goregaokar
* Mark-Simulacrum
* Matthew Piziak
* Matt Ickstadt
* mcarton
* Michael Layne
* Michael Woerister
* Mikhail Modin
* Mohit Agarwal
* Nazım Can Altınova
* Neil Williams
* Nicholas Nethercote
* Nick Cameron
* Nick Platt
* Niels Sascha Reedijk
* Nikita Baksalyar
* Niko Matsakis
* Oliver Middleton
* Oliver Schneider
* orbea
* Panashe M. Fundira
* Patrick Walton
* Paul Fanelli
* philipp
* Phil Ruffwind
* Piotr Jawniak
* pliniker
* QuietMisdreavus
* Rahul Sharma
* Richard Janis Goldschmidt
* Scott A Carr
* Scott Olson
* Sean McArthur
* Sebastian Ullrich
* Sébastien Marie
* Seo Sanghyeon
* Sergio Benitez
* Shyam Sundar B
* silenuss
* Simonas Kazlauskas
* Simon Sapin
* Srinivas Reddy Thatiparthy
* Stefan Schindler
* Stephan Hügel
* Steve Klabnik
* Steven Allen
* Steven Fackler
* Terry Sun
* Thomas Garcia
* Tim Neumann
* Tobias Bucher
* Tomasz Miąsko
* trixnz
* Tshepang Lekhonkhobe
* Ulrich Weigand
* Ulrik Sverdrup
* Vadim Chugunov
* Vadim Petrochenkov
* Vanja Cosic
* Vincent Esche
* Wesley Wiser
* William Lee
* Ximin Luo
* Yossi Konstantinovsky
* zjhmale
