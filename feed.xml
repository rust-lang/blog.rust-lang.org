<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-01-25T04:46:40+00:00</updated>

    
    <entry>
        <title>Officially announcing the types team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/20/types-announcement.html" type="text/html" title="Officially announcing the types team" />
        <published>2023-01-20T00:00:00+00:00</published>
        <updated>2023-01-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/20/types-announcement.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/20/types-announcement.html">&lt;p&gt;Oh hey, it&#x27;s &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html&quot;&gt;another&lt;/a&gt; new team announcement. But I will admit: if you follow the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3254&quot;&gt;RFCs repository&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/144729-t-types&quot;&gt;Rust zulip&lt;/a&gt;, or were particularly observant on the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;GATs stabilization announcement post&lt;/a&gt;, then this &lt;em&gt;might&lt;/em&gt; not be a surprise for you. In fact, this &amp;quot;new&amp;quot; team was officially established at the end of May last year.&lt;/p&gt;
&lt;p&gt;There are a few reasons why we&#x27;re sharing this post now (as opposed to months before or...never). First, the team finished a three day in-person/hybrid meetup at the beginning of December and we&#x27;d like to share the purpose and outcomes of that meeting. Second, posting this announcement now is just around 7 months of activity and we&#x27;d love to share what we&#x27;ve accomplished within this time. Lastly, as we enter into the new year of 2023, it&#x27;s a great time to share a bit of where we expect to head in this year and beyond.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#background---how-did-we-get-here&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;background---how-did-we-get-here&quot;&gt;&lt;/a&gt;Background - How did we get here?&lt;/h2&gt;
&lt;p&gt;Rust has grown significantly in the last several years, in many metrics: users, contributors, features, tooling, documentation, and more. As it has grown, the list of &lt;em&gt;things&lt;/em&gt; people want to do with it has grown just as quickly. On top of powerful and ergonomic features, the demand for powerful tools such as IDEs or learning tools for the language has become more and more apparent. New compilers (frontend and backend) are being written. And, to top it off, we want Rust to continue to maintain one of its core design principles: safety.&lt;/p&gt;
&lt;p&gt;All of these points highlights some key needs: to be able to &lt;em&gt;know&lt;/em&gt; how the Rust language should work, to be able to &lt;em&gt;extend&lt;/em&gt; the language and compiler with new features in a relatively painless way, to be able to &lt;em&gt;hook into&lt;/em&gt; the compiler and be able to query important information about programs, and finally to be able to &lt;em&gt;maintain&lt;/em&gt; the language and compiler in an amenable and robust way. Over the years, considerable effort has been put into these needs, but we haven&#x27;t &lt;em&gt;quite&lt;/em&gt; achieved these key requirements.&lt;/p&gt;
&lt;p&gt;To extend a little, and put some numbers to paper, there are currently around 220 open tracking issues for &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+is%3Aissue+label%3AC-tracking-issue+label%3AT-lang&quot;&gt;language&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?page&#x3D;1&amp;amp;q&#x3D;is%3Aopen+is%3Aissue+label%3AC-tracking-issue+label%3AT-compiler&quot;&gt;compiler&lt;/a&gt;, or &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+is%3Aissue+label%3AC-tracking-issue+label%3AT-types&quot;&gt;types&lt;/a&gt; features that have been accepted but are not completely implemented, of which about half are at least 3 years old and many are several years older than that. Many of these tracking issues have been open for so long not solely because of bandwidth, but because working on these features is hard, in large part because putting the relevant semantics in context of the larger language properly is hard; it&#x27;s not easy for anyone to take a look at them and know what needs to be done to finish them. It&#x27;s clear that we still need better foundations for making changes to the language and compiler.&lt;/p&gt;
&lt;p&gt;Another number that might shock you: there are currently 62 open &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+is%3Aissue+label%3AI-unsound&quot;&gt;unsoundness issues&lt;/a&gt;. This sounds &lt;em&gt;much&lt;/em&gt; scarier than it really is: nearly all of these are edges of the compiler and language that have been found by people who specifically poke and prod to find them; in practice these will not pop up in the programs you write. Nevertheless, these are edges we want to iron out.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-types-team&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-types-team&quot;&gt;&lt;/a&gt;The Types Team&lt;/h2&gt;
&lt;p&gt;Moving forward, let&#x27;s talk about a smaller subset of Rust rather than the entire language and compiler. Specifically, the parts relevant here include the type checker - loosely, defining the semantics and implementation of how variables are assigned their type, trait solving - deciding what traits are defined for which types, and borrow checking - proving that Rust&#x27;s ownership model always holds. All of these can be thought of cohesively as the &amp;quot;type system&amp;quot;.&lt;/p&gt;
&lt;p&gt;As of &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3254-types-team.html&quot;&gt;RFC 3254&lt;/a&gt;, the above subset of the Rust language and compiler are under the purview of the types team. So, what exactly does this entail?&lt;/p&gt;
&lt;p&gt;First, since around 2018, there existed the &amp;quot;traits working group&amp;quot;, which had the primary goal of creating a performant and extensible definition and implementation of Rust&#x27;s trait system (including the &lt;a href&#x3D;&quot;https://github.com/rust-lang/chalk&quot;&gt;Chalk&lt;/a&gt; trait-solving library). As time progressed, and particularly in the latter half of 2021 into 2022, the working group&#x27;s influence and responsibility naturally expanded to the type checker and borrow checker too - they are actually strongly linked and its often hard to disentangle the trait solver from the other two. So, in some ways, the types team essentially subsumes the former traits working group.&lt;/p&gt;
&lt;p&gt;Another relevant working group is the &lt;a href&#x3D;&quot;https://rust-lang.github.io/compiler-team/working-groups/polonius/&quot;&gt;polonius working group&lt;/a&gt;, which primarily works on the design and implementation of the &lt;a href&#x3D;&quot;https://github.com/rust-lang/polonius&quot;&gt;Polonius&lt;/a&gt; borrow-checking library. While the working group itself will remain, it is now also under the purview of the types team.&lt;/p&gt;
&lt;p&gt;Now, although the traits working group was essentially folded into the types team, the creation of a &lt;em&gt;team&lt;/em&gt; has some benefits. First, like the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html&quot;&gt;style team&lt;/a&gt; (and many other teams), the types team is not a &lt;em&gt;top level&lt;/em&gt; team. It actually, currently uniquely, has &lt;em&gt;two&lt;/em&gt; parent teams: the lang and compiler teams. Both teams have decided to delegate decision-making authority covering the type system.&lt;/p&gt;
&lt;p&gt;The language team has delegated the part of the &lt;em&gt;design&lt;/em&gt; of type system. However, importantly, this design covers less of the &amp;quot;feel&amp;quot; of the features of type system and more of how it &amp;quot;works&amp;quot;, with the expectation that the types team will advise and bring concerns about new language extensions where required. (This division is not strongly defined, but the expectation is generally to err on the side of more caution). The compiler team, on the other hand, has delegated the responsibility of defining and maintaining the implementation of the trait system.&lt;/p&gt;
&lt;p&gt;One particular responsibility that has traditionally been shared between the language and compiler teams is the assessment and fixing of soundness bugs in the language related to the type system. These often arise from implementation-defined language semantics and have in the past required synchronization and input from both lang and compiler teams. In the majority of cases, the types team now has the authority to assess and implement fixes without the direct input from either parent team. This applies, importantly, for fixes that are &lt;em&gt;technically&lt;/em&gt; backwards-incompatible. While fixing safety holes is &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2014/10/30/Stability.html#what-are-the-stability-caveats&quot;&gt;not covered under Rust&#x27;s backwards compatibility guarantees&lt;/a&gt;, these decisions are not taken lightly and generally require team signoff and are assessed for potential ecosystem breakage with &lt;a href&#x3D;&quot;https://github.com/rust-lang/crater&quot;&gt;crater&lt;/a&gt;. However, this can now be done under one team rather than requiring the coordination of two separate teams, which makes closing these soundness holes easier (I will discuss this more later.)&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#formalizing-the-rust-type-system&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;formalizing-the-rust-type-system&quot;&gt;&lt;/a&gt;Formalizing the Rust type system&lt;/h2&gt;
&lt;p&gt;As mentioned above, a nearly essential element of the growing Rust language is to know how it &lt;em&gt;should&lt;/em&gt; work (and to have this well documented). There are relatively recent efforts pushing for a Rust specification (like &lt;a href&#x3D;&quot;https://github.com/ferrocene/specification&quot;&gt;Ferrocene&lt;/a&gt; or &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3355&quot;&gt;this open RFC&lt;/a&gt;), but it would be hugely beneficial to have a formalized definition of the type system, regardless of its potential integration into a more general specification. In fact the existence of a formalization would allow a better assessment of potential new features or soundness holes, without the subtle intricacies of the rest of the compiler.&lt;/p&gt;
&lt;p&gt;As far back as 2015, not long after the release of Rust 1.0, an experimental Rust trait solver called Chalk began to be written. The core idea of Chalk is to translate the surface syntax and ideas of the Rust trait system (e.g. traits, impls, where clauses) into a set of logic rules that can be solved using a Prolog-like solver. Then, once this set of logic and solving reaches parity with the trait solver within the compiler itself, the plan was to simply replace the existing solver. In the meantime (and continuing forward), this new solver could be used by other tools, such as rust-analyzer, where it is used today.&lt;/p&gt;
&lt;p&gt;Now, given Chalk&#x27;s age and the promises it had been hoped to be able to deliver on, you might be tempted to ask the question &amp;quot;Chalk, when?&amp;quot; - and plenty have. However, we&#x27;ve learned over the years that Chalk is likely not the correct long-term solution for Rust, for a few reasons. First, as mentioned a few times in this post, the trait solver is only but a part of a larger type system; and modeling how the entire type system fits together gives a more complete picture of its details than trying to model the parts separately. Second, the needs of the &lt;em&gt;compiler&lt;/em&gt; are quite different than the needs of a &lt;em&gt;formalization&lt;/em&gt;: the compiler needs performant code with the ability to track information required for powerful diagnostics; a good formalization is one that is not only complete, but also easy to maintain, read, and understand. Over the years, Chalk has tried to have both and it has so far ended up with neither.&lt;/p&gt;
&lt;p&gt;So, what are the plans going forward? Well, first the types team has begun working on a formalization of the Rust typesystem, currently coined &lt;a href&#x3D;&quot;https://github.com/nikomatsakis/a-mir-formality/&quot;&gt;a-mir-formality&lt;/a&gt;. An initial experimental phase was written using &lt;a href&#x3D;&quot;https://redex.racket-lang.org/&quot;&gt;PLT redex&lt;/a&gt;, but a Rust port is in-progress. There&#x27;s lot to do still (including modeling more of the trait system, writing an RFC, and moving it into the rust-lang org), but it&#x27;s already showing great promise.&lt;/p&gt;
&lt;p&gt;Second, we&#x27;ve begun an &lt;a href&#x3D;&quot;https://github.com/rust-lang/types-team/issues/58&quot;&gt;initiative&lt;/a&gt; for writing a new trait solver in-tree. This new trait solver is more limited in scope than a-mir-formality (i.e. not intending to encompass the entire type system). In many ways, it&#x27;s expected to be quite similar to Chalk, but leverage bits and pieces of the existing compiler and trait solver in order to make the transition as painless as possible. We do expect it to be pulled out-of-tree at some point, so it&#x27;s being written to be as modular as possible. During our types team meetup earlier this month, we were able to hash out what we expect the structure of the solver to look like, and we&#x27;ve already gotten that &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/105661&quot;&gt;merged into the source tree&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, Chalk is no longer going to be a focus of the team. In the short term, it still may remain a useful tool for experimentation. As said before, rust-analyzer uses Chalk as its trait solver. It&#x27;s also able to be used in rustc under an unstable feature flag. Thus, new ideas currently could be implemented in Chalk and battle-tested in practice. However, this benefit will likely not last long as a-mir-formality and the new in-tree trait solver get more usable and their interfaces become more accessible. All this is not to say that Chalk has been a failure. In fact, Chalk has taught us a lot about how to think about the Rust trait solver in a logical way and the current Rust trait solver has evolved over time to more closely model Chalk, even if incompletely. We expect to still support Chalk in some capacity for the time being, for rust-analyzer and potentially for those interested in experimenting with it.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#closing-soundness-holes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;closing-soundness-holes&quot;&gt;&lt;/a&gt;Closing soundness holes&lt;/h2&gt;
&lt;p&gt;As brought up previously, a big benefit of creating a new types team with delegated authority from both the lang and compiler teams is the authority to assess and fix unsoundness issues mostly independently. However, a secondary benefit has actually just been better procedures and knowledge-sharing that allows the members of the team to get on the same page for what soundness issues there are, why they exist, and what it takes to fix them. For example, during our meetup earlier this month, we were able to go through the full list of soundness issues (focusing on those relevant to the type system), identify their causes, and discuss expected fixes (though most require prerequisite work discussed in the previous section).&lt;/p&gt;
&lt;p&gt;Additionally, the team has already made a number of soundness fixes and has a few more in-progress. I won&#x27;t go into details, but instead am just opting to putting them in list form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/99217&quot;&gt;Consider unnormalized types for implied bounds&lt;/a&gt;: landed in 1.65, no regressions found&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/95474&quot;&gt;Neither require nor imply lifetime bounds on opaque type for well formedness&lt;/a&gt;: landed in 1.66, no regressions found&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/105575&quot;&gt;Add &lt;code&gt;IMPLIED_BOUNDS_ENTAILMENT&lt;/code&gt; lint&lt;/a&gt;: landing in 1.68, future-compat lint because many regressions found (of unsoundness)&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/105102&quot;&gt;Check ADT fields for copy implementations considering regions&lt;/a&gt;: currently open, ready to land&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/100046&quot;&gt;Register wf obligation before normalizing in wfcheck&lt;/a&gt;: currently open, regressions found, needs additional work&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/100555&quot;&gt;Handle projections as uncovered types during coherence check&lt;/a&gt;: currently open, some regressions found, future-compat lint suggested&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/101947&quot;&gt;Don&#x27;t normalize in AstConv&lt;/a&gt;: landing in 1.68, 1 small regression found&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see, we&#x27;re making progress on closing soundness holes. These sometimes break code, as assessed by crater. However, we do what we can to mitigate this, even when the code being broken is technically unsound.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#new-features&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-features&quot;&gt;&lt;/a&gt;New features&lt;/h2&gt;
&lt;p&gt;While it&#x27;s not technically under the types team purview to &lt;em&gt;propose and design&lt;/em&gt; new features (these fall more under lang team proper), there are a few instances where the team is heavily involved (if not driving) feature design.&lt;/p&gt;
&lt;p&gt;These can be small additions, which are close to bug fixes. For example, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/104765&quot;&gt;this PR&lt;/a&gt; allows more permutations of lifetime outlives bounds than what compiled previously. Or, these PRs can be larger, more impactful changes, that don&#x27;t fit under a &amp;quot;feature&amp;quot;, but instead are tied heavily to the type system. For example, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/100386&quot;&gt;this PR&lt;/a&gt; makes the &lt;code&gt;Sized&lt;/code&gt; trait coinductive, which effectively makes more cyclic bounds compile (see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/100386/files#diff-7efe7060b98871be57269858d3abd0c9a6f877a6c65fd0fba54ef122cd2d5281&quot;&gt;this test&lt;/a&gt; for an example).&lt;/p&gt;
&lt;p&gt;There are also a few larger features and feature sets that have been driven by the types team, largely due to the heavy intersection with the type system. Here are a few examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generic associated types (GATs) - The feature long predates the types team and is the only one in this list that has actually been stabilized so far. But due to heavy type system interaction, the team was able to navigate the issues that came on its final path to stabilization. See &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;this blog post&lt;/a&gt; for much more details.&lt;/li&gt;
&lt;li&gt;Type alias impl trait (TAITs) - Implementing this feature &lt;em&gt;properly&lt;/em&gt; requires a thorough understanding of the type checker. This is close to stabilization. For more information, see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/63063&quot;&gt;the tracking issue&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Trait upcasting - This one is relatively small, but has some type system interaction. Again, see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65991&quot;&gt;the tracking issue&lt;/a&gt; for an explanation of the feature.&lt;/li&gt;
&lt;li&gt;Negative impls - This too predates the types team, but has recently been worked on by the team. There are still open bugs and soundness issues, so this is a bit away from stabilization, but you can follow &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/68318&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Return position impl traits in traits (RPITITs) and async functions in traits (AFITs) - These have only recently been possible with advances made with GATs and TAITs. They are currently tracked under a single &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/91611&quot;&gt;tracking issue&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#roadmap&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;roadmap&quot;&gt;&lt;/a&gt;Roadmap&lt;/h2&gt;
&lt;p&gt;To conclude, let&#x27;s put all of this onto a roadmap. As always, goals are best when they are specific, measurable, and time-bound. For this, we&#x27;ve decided to split our goals into roughly 4 stages: summer of 2023, end-of-year 2023, end-of-year 2024, and end-of-year 2027 (6 months, 1 year, 2 years, and 5 years). Overall, our goals are to build a platform to maintain a sound, testable, and documented type system that can scale to new features need by the Rust language. Furthermore, we want to cultivate a sustainable and open-source team (the types team) to maintain that platform and type system.&lt;/p&gt;
&lt;p&gt;A quick note: some of the things here have not quite been explained in this post, but they&#x27;ve been included in the spirit of completeness. So, without further ado:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 months&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The work-in-progress new trait solver should be testable&lt;/li&gt;
&lt;li&gt;a-mir-formality should be testable against the Rust test suite&lt;/li&gt;
&lt;li&gt;Both TAITs and RPITITs/AFITs should be stabilized or on the path to stabilization.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EOY 2023&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New trait solver replaces part of existing trait solver, but not used everywhere&lt;/li&gt;
&lt;li&gt;We have an onboarding plan (for the team) and documentation for the new trait solver&lt;/li&gt;
&lt;li&gt;a-mir-formality is integrated into the language design process&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EOY 2024&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New trait solver shared by rustc and rust-analyzer
&lt;ul&gt;
&lt;li&gt;Milestone: Type IR shared&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We have a clean API for extensible trait errors that is available at least internally&lt;/li&gt;
&lt;li&gt;&amp;quot;Shiny features&amp;quot;
&lt;ul&gt;
&lt;li&gt;Polonius in a usable state&lt;/li&gt;
&lt;li&gt;Implied bounds in higher-ranked trait bounds (see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/90696&quot;&gt;this issue&lt;/a&gt; for an example of an issue this would fix)&lt;/li&gt;
&lt;li&gt;Being able to use &lt;code&gt;impl Trait&lt;/code&gt; basically anywhere&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Potential edition boundary changes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EOY 2027&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Types) unsound issues resolved&lt;/li&gt;
&lt;li&gt;Most language extensions are easy to do; large extensions are feasible&lt;/li&gt;
&lt;li&gt;a-mir-formality passes 99.9% of the Rust test suite&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It&#x27;s an exciting time for Rust. As its userbase and popularity grows, the language does as well. And as the language grows, the need for a sustainable type system to support the language becomes ever more apparent. The project has formed this new types team to address this need and hopefully, in this post, you can see that the team has so far accomplished a lot. And we expect that trend to only continue over the next many years.&lt;/p&gt;
&lt;p&gt;As always, if you&#x27;d like to get involved or have questions, please drop by the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/144729-t-types&quot;&gt;Rust zulip&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Jack Huey</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for Cargo (CVE-2022-46176)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html" type="text/html" title="Security advisory for Cargo (CVE-2022-46176)" />
        <published>2023-01-10T00:00:00+00:00</published>
        <updated>2023-01-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/v5cFFJ7T0RY&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that Cargo did not perform SSH host
key verification when cloning indexes and dependencies via SSH. An attacker
could exploit this to perform man-in-the-middle (MITM) attacks.&lt;/p&gt;
&lt;p&gt;This vulnerability has been assigned CVE-2022-46176.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;When an SSH client establishes communication with a server, to prevent MITM
attacks the client should check whether it already communicated with that
server in the past and what the server&#x27;s public key was back then. If the key
changed since the last connection, the connection must be aborted as a MITM
attack is likely taking place.&lt;/p&gt;
&lt;p&gt;It was discovered that Cargo never implemented such checks, and performed no
validation on the server&#x27;s public key, leaving Cargo users vulnerable to MITM
attacks.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;All Rust versions containing Cargo before 1.66.1 are vulnerable.&lt;/p&gt;
&lt;p&gt;Note that even if you don&#x27;t explicitly use SSH for alternate registry indexes
or crate dependencies, you might be affected by this vulnerability if you have
configured git to replace HTTPS connections to GitHub with SSH (through git&#x27;s
&lt;a href&#x3D;&quot;https://git-scm.com/docs/git-config#Documentation/git-config.txt-urlltbasegtinsteadOf&quot;&gt;&lt;code&gt;url.&amp;lt;base&amp;gt;.insteadOf&lt;/code&gt;&lt;/a&gt; setting), as that&#x27;d cause you to clone the
crates.io index through SSH.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We will be releasing Rust 1.66.1 today, 2023-01-10, changing Cargo to check the
SSH host key and abort the connection if the server&#x27;s public key is not already
trusted. We recommend everyone to upgrade as soon as possible.&lt;/p&gt;
&lt;p&gt;Patch files for Rust 1.66.0 are also available &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/main/patches/CVE-2022-46176&quot;&gt;here&lt;/a&gt; for custom-built
toolchains.&lt;/p&gt;
&lt;p&gt;For the time being Cargo will not ask the user whether to trust a server&#x27;s
public key during the first connection. Instead, Cargo will show an error
message detailing how to add that public key to the list of trusted keys. Note
that this might break your automated builds if the hosts you clone dependencies
or indexes from are not already trusted.&lt;/p&gt;
&lt;p&gt;If you can&#x27;t upgrade to Rust 1.66.1 yet, we recommend configuring Cargo to use
the &lt;code&gt;git&lt;/code&gt; CLI instead of its built-in git support. That way, all git network
operations will be performed by the &lt;code&gt;git&lt;/code&gt; CLI, which is not affected by this
vulnerability. You can do so by adding this snippet to your &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html&quot;&gt;Cargo
configuration file&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[net]
git-fetch-with-cli &#x3D; true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks to the Julia Security Team for disclosing this to us according to our
&lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We also want to thank the members of the Rust project who contributed to fixing
this issue. Thanks to Eric Huss and Weihang Lo for writing and reviewing the
patch, Pietro Albini for coordinating the disclosure and writing this advisory,
and Josh Stone, Josh Triplett and Jacob Finkelman for advising during the
disclosure.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Updated on 2023-01-10 at 21:30 UTC to include additional mitigations.&lt;/em&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.66.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/10/Rust-1.66.1.html" type="text/html" title="Announcing Rust 1.66.1" />
        <published>2023-01-10T00:00:00+00:00</published>
        <updated>2023-01-10T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/10/Rust-1.66.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/10/Rust-1.66.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.66.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.66.1 with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1661-2023-01-10&quot;&gt;detailed release notes for 1.66.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1661-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1661-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.66.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.66.1 fixes Cargo not verifying SSH host keys when cloning dependencies
or registry indexes with SSH. This security vulnerability is tracked as
&lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2022-46176&quot;&gt;CVE-2022-46176&lt;/a&gt;, and you &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html&quot;&gt;can find more details in the advisory&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1661&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1661&quot;&gt;&lt;/a&gt;Contributors to 1.66.1&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.66.1. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.66.1/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Updating the Android NDK in Rust 1.68</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html" type="text/html" title="Updating the Android NDK in Rust 1.68" />
        <published>2023-01-09T00:00:00+00:00</published>
        <updated>2023-01-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html">&lt;p&gt;We are pleased to announce that Android platform support in Rust will be
modernized in Rust 1.68 as we update the target NDK from r17 to r25.  As a
consequence the minimum supported API level will increase from 15 (Ice Cream
Sandwich) to 19 (KitKat).&lt;/p&gt;
&lt;p&gt;In NDK r23 Android switched to using LLVM&#x27;s &lt;code&gt;libunwind&lt;/code&gt; for all architectures.
This meant that&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If a project were to target NDK r23 or newer with previous versions of Rust
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/85806#issuecomment-1096266946&quot;&gt;a workaround&lt;/a&gt;
would be required to redirect attempts to link against &lt;code&gt;libgcc&lt;/code&gt; to instead
link against &lt;code&gt;libunwind&lt;/code&gt;.  Following this update this workaround will no
longer be necessary.&lt;/li&gt;
&lt;li&gt;If a project uses NDK r22 or older it will need to be updated to use &lt;a href&#x3D;&quot;https://developer.android.com/ndk/downloads&quot;&gt;r23 or
newer&lt;/a&gt;.  Information about the
layout of the NDK&#x27;s toolchain can be found
&lt;a href&#x3D;&quot;https://developer.android.com/ndk/guides/other_build_systems&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Going forward the Android platform will target the most recent LTS NDK, allowing
Rust developers to access platform features sooner.  These updates should occur
yearly and will be announced in release notes.&lt;/p&gt;
</content>

        <author>
            <name>Android Platform Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.66.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html" type="text/html" title="Announcing Rust 1.66.0" />
        <published>2022-12-15T00:00:00+00:00</published>
        <updated>2022-12-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.66.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.66.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;detailed release notes for
1.66.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1660-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1660-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.66.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#explicit-discriminants-on-enums-with-fields&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;explicit-discriminants-on-enums-with-fields&quot;&gt;&lt;/a&gt;Explicit discriminants on enums with fields&lt;/h3&gt;
&lt;p&gt;Enums with integer representations can now use explicit discriminants, even when they have fields.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[repr(u8)]
enum Foo {
    A(u8),
    B(i8),
    C(bool) &#x3D; 42,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, you could use explicit discriminants on enums with representations, but only if none of their variants had fields. Explicit discriminants are useful when passing values across language boundaries where the representation of the enum needs to match in both languages. For example,&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[repr(u8)]
enum Bar {
    A,
    B,
    C &#x3D; 42,
    D,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;Bar&lt;/code&gt; enum is guaranteed to have the same layout as &lt;code&gt;u8&lt;/code&gt;. In addition, the &lt;code&gt;Bar::C&lt;/code&gt; variant is guaranteed to have a discriminant of 42. Variants without explicitly-specified values will have discriminants that are automatically assigned according to their order in the source code, so &lt;code&gt;Bar::A&lt;/code&gt; will have a discriminant of 0, &lt;code&gt;Bar::B&lt;/code&gt; will have a discriminant of 1, and &lt;code&gt;Bar::D&lt;/code&gt; will have a discriminant of 43. Without this feature, the only way to set the explicit value of &lt;code&gt;Bar::C&lt;/code&gt; would be to add 41 unnecessary variants before it!&lt;/p&gt;
&lt;p&gt;Note: whereas for field-less enums it is possible to inspect a discriminant via &lt;code&gt;as&lt;/code&gt; casting (e.g. &lt;code&gt;Bar::C as u8&lt;/code&gt;), Rust provides no language-level way to access the raw discriminant of an enum with fields. Instead, currently unsafe code must be used to inspect the discriminant of an enum with fields. Since this feature is intended for use with cross-language FFI where unsafe code is already necessary, this should hopefully not be too much of an extra burden. In the meantime, if all you need is an opaque handle to the discriminant, please see the &lt;code&gt;std::mem::discriminant&lt;/code&gt; function.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#corehintblack_box&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;corehintblack_box&quot;&gt;&lt;/a&gt;&lt;code&gt;core::hint::black_box&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;When benchmarking or examining the machine code produced by a compiler, it&#x27;s often useful to prevent optimizations from occurring in certain places. In the following example, the function &lt;code&gt;push_cap&lt;/code&gt; executes &lt;code&gt;Vec::push&lt;/code&gt; 4 times in a loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn push_cap(v: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    for i in 0..4 {
        v.push(i);
    }
}

pub fn bench_push() -&amp;gt; Duration { 
    let mut v &#x3D; Vec::with_capacity(4);
    let now &#x3D; Instant::now();
    push_cap(&amp;amp;mut v);
    now.elapsed()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you inspect the optimized output of the compiler on x86_64, you&#x27;ll notice that it looks rather short:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-asm&quot;&gt;example::bench_push:
  sub rsp, 24
  call qword ptr [rip + std::time::Instant::now@GOTPCREL]
  lea rdi, [rsp + 8]
  mov qword ptr [rsp + 8], rax
  mov dword ptr [rsp + 16], edx
  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]
  add rsp, 24
  ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, the entire function &lt;code&gt;push_cap&lt;/code&gt; we wanted to benchmark has been optimized away!&lt;/p&gt;
&lt;p&gt;We can work around this using the newly stabilized &lt;code&gt;black_box&lt;/code&gt; function. Functionally, &lt;code&gt;black_box&lt;/code&gt; is not very interesting: it takes the value you pass it and passes it right back. Internally, however, the compiler treats &lt;code&gt;black_box&lt;/code&gt; as a function that could do anything with its input and return any value (as its name implies).&lt;/p&gt;
&lt;p&gt;This is very useful for disabling optimizations like the one we see above. For example, we can hint to the compiler that the vector will actually be used for something after every iteration of the for loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::hint::black_box;

fn push_cap(v: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    for i in 0..4 {
        v.push(i);
        black_box(v.as_ptr());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can find the unrolled for loop in our &lt;a href&#x3D;&quot;https://rust.godbolt.org/z/Ws1GGbY6Y&quot;&gt;optimized assembly output&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-asm&quot;&gt;  mov dword ptr [rbx], 0
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 4], 1
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 8], 2
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 12], 3
  mov qword ptr [rsp + 8], rbx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also see a side effect of calling &lt;code&gt;black_box&lt;/code&gt; in this assembly output. The instruction &lt;code&gt;mov qword ptr [rsp + 8], rbx&lt;/code&gt; is uselessly repeated after every iteration. This instruction writes the address &lt;code&gt;v.as_ptr()&lt;/code&gt; as the first argument of the function, which is never actually called.&lt;/p&gt;
&lt;p&gt;Notice that the generated code is not at all concerned with the possibility of allocations introduced by the &lt;code&gt;push&lt;/code&gt; call. This is because the compiler is still using the fact that we called &lt;code&gt;Vec::with_capacity(4)&lt;/code&gt; in the &lt;code&gt;bench_push&lt;/code&gt; function. You can play around with the placement of &lt;code&gt;black_box&lt;/code&gt;, or try using it in multiple places, to see its effects on compiler optimizations.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-remove&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-remove&quot;&gt;&lt;/a&gt;cargo remove&lt;/h3&gt;
&lt;p&gt;In Rust 1.62.0 we introduced &lt;code&gt;cargo add&lt;/code&gt;, a command line utility to add dependencies to your project. Now you can use &lt;code&gt;cargo remove&lt;/code&gt; to remove dependencies.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.source_text&quot;&gt;&lt;code&gt;proc_macro::Span::source_text&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.checked_add_signed&quot;&gt;&lt;code&gt;u*::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_add_unsigned&quot;&gt;&lt;code&gt;i*::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_sub_unsigned&quot;&gt;&lt;code&gt;i*::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.first&quot;&gt;&lt;code&gt;BTreeSet::{first, last, pop_first, pop_last}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.first_key_value&quot;&gt;&lt;code&gt;BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/101768/&quot;&gt;Add &lt;code&gt;AsFd&lt;/code&gt; implementations for stdio lock types on WASI.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-Box%3C%5BT%3B%20N%5D%2C%20Global%3E&quot;&gt;&lt;code&gt;impl TryFrom&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Box&amp;lt;[T; N]&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/hint/fn.black_box.html&quot;&gt;&lt;code&gt;core::hint::black_box&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.try_from_secs_f32&quot;&gt;&lt;code&gt;Duration::try_from_secs_{f32,f64}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unzip&quot;&gt;&lt;code&gt;Option::unzip&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/fd/index.html&quot;&gt;&lt;code&gt;std::os::fd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.66 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can now use &lt;code&gt;..&#x3D;X&lt;/code&gt; ranges in patterns.&lt;/li&gt;
&lt;li&gt;Linux builds now optimize the rustc frontend and LLVM backend with LTO and BOLT, respectively, improving both runtime performance and memory usage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-166-2022-12-15&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-166&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1660&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1660&quot;&gt;&lt;/a&gt;Contributors to 1.66.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.66.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.66.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Launching the 2022 State of Rust Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/12/05/survey-launch.html" type="text/html" title="Launching the 2022 State of Rust Survey" />
        <published>2022-12-05T00:00:00+00:00</published>
        <updated>2022-12-05T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/12/05/survey-launch.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/12/05/survey-launch.html">&lt;p&gt;The &lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd&quot;&gt;2022 State of Rust Survey&lt;/a&gt; is here!&lt;/p&gt;
&lt;p&gt;It&#x27;s that time again! Time for us to take a look at who the Rust community is composed of, how the Rust project is doing, and how we can improve the Rust programming experience. The Rust Survey working group is pleased to announce our &lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd&quot;&gt;2022 State of Rust Survey&lt;/a&gt;! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses, and establish development priorities for the future.&lt;/p&gt;
&lt;p&gt;Completing this survey should take about 5–20 minutes and is anonymous. We will be accepting submissions for the next two weeks (until the 19th of December), and we will share our findings on &lt;a href&#x3D;&quot;https://blog.rust-lang.org&quot;&gt;blog.rust-lang.org&lt;/a&gt; sometime in early 2023. You can also check out &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html&quot;&gt;last year’s results&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We&#x27;re happy to be offering the survey in the following languages. If you speak multiple languages, please pick one.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;en&quot;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;zh-cn&quot;&gt;Simplified Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;zh-tw&quot;&gt;Traditional Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;fr&quot;&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;de&quot;&gt;German&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ja&quot;&gt;Japanese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ko&quot;&gt;Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;pt&quot;&gt;Portuguese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ru&quot;&gt;Russian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;es&quot;&gt;Spanish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;uk&quot;&gt;Ukrainian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please help us spread the word by sharing the survey link on your social network feeds, at meetups, around your office, and in other communities.&lt;/p&gt;
&lt;p&gt;If you have any questions, please see our &lt;a href&#x3D;&quot;https://github.com/rust-lang/surveys/blob/main/documents/Community-Survey-FAQ.md&quot;&gt;frequently asked questions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we wanted to thank everyone who helped develop, polish, and test the survey.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.65.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html" type="text/html" title="Announcing Rust 1.65.0" />
        <published>2022-11-03T00:00:00+00:00</published>
        <updated>2022-11-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.65.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Before going into the details of the new Rust release, we&#x27;d like to draw
attention to the tragic &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Death_of_Mahsa_Amini&quot;&gt;death of Mahsa
Amini&lt;/a&gt; and the death and
violent suppression of many others, by the religious morality police of Iran.
See &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Mahsa_Amini_protests&quot;&gt;https://en.wikipedia.org/wiki/Mahsa_Amini_protests&lt;/a&gt; for more details. We
stand in solidarity with the people in Iran struggling for human rights.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.65.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;detailed release notes for
1.65.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1650-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1650-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.65.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#generic-associated-types-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;generic-associated-types-gats&quot;&gt;&lt;/a&gt;Generic associated types (GATs)&lt;/h3&gt;
&lt;p&gt;Lifetime, type, and const generics can now be defined on associated types, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Foo {
    type Bar&amp;lt;&#x27;x&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#x27;s hard to put into few words just how useful these can be, so here are a
few example traits, to get a sense of their power:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// An &#x60;Iterator&#x60;-like trait that can borrow from &#x60;Self&#x60;
trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;lt;&#x27;a&amp;gt;&amp;gt;;
}

/// Can be implemented over smart pointers, like &#x60;Rc&#x60; or &#x60;Arc&#x60;,
/// in order to allow being generic over the pointer type
trait PointerFamily {
    type Pointer&amp;lt;T&amp;gt;: Deref&amp;lt;Target &#x3D; T&amp;gt;;

    fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Self::Pointer&amp;lt;T&amp;gt;;
}

/// Allows borrowing an array of items. Useful for
/// &#x60;NdArray&#x60;-like types that don&#x27;t necessarily store
/// data contiguously.
trait BorrowArray&amp;lt;T&amp;gt; {
    type Array&amp;lt;&#x27;x, const N: usize&amp;gt; where Self: &#x27;x;

    fn borrow_array&amp;lt;&#x27;a, const N: usize&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; Self::Array&amp;lt;&#x27;a, N&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, GATs are quite versatile and enable a number
of patterns that are not currently able to be written. For more
information, check out the post announcing the
&lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization&lt;/a&gt;
published last year or the
&lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;stabilization announcement post&lt;/a&gt;
published last week. The former goes into a bit more depth
of a couple of the examples above, while the latter talks
about some of the known limitations of this stabilization.&lt;/p&gt;
&lt;p&gt;More in depth reading can be found in the associated types
section of the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/items/associated-items.html#associated-types&quot;&gt;nightly reference&lt;/a&gt;
or the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/1598-generic_associated_types.html&quot;&gt;original RFC&lt;/a&gt; (which was initially opened over 6.5 years ago!).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#let-else-statements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;let-else-statements&quot;&gt;&lt;/a&gt;&lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statements&lt;/h3&gt;
&lt;p&gt;This introduces a new type of &lt;code&gt;let&lt;/code&gt; statement with a refutable pattern and a
diverging &lt;code&gt;else&lt;/code&gt; block that executes when that pattern doesn&#x27;t match.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let PATTERN: TYPE &#x3D; EXPRESSION else {
    DIVERGING_CODE;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normal &lt;code&gt;let&lt;/code&gt; statements can only use &lt;em&gt;irrefutable&lt;/em&gt; patterns, statically known
to always match. That pattern is often just a single variable binding, but may
also unpack compound types like structs, tuples, and arrays. However, that was
not usable for conditional matches, like pulling out a variant of an enum --
until now! With &lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, a refutable pattern can match and bind variables
in the surrounding scope like a normal &lt;code&gt;let&lt;/code&gt;, or else diverge (e.g. &lt;code&gt;break&lt;/code&gt;,
&lt;code&gt;return&lt;/code&gt;, &lt;code&gt;panic!&lt;/code&gt;) when the pattern doesn&#x27;t match.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn get_count_item(s: &amp;amp;str) -&amp;gt; (u64, &amp;amp;str) {
    let mut it &#x3D; s.split(&#x27; &#x27;);
    let (Some(count_str), Some(item)) &#x3D; (it.next(), it.next()) else {
        panic!(&amp;quot;Can&#x27;t segment count item pair: &#x27;{s}&#x27;&amp;quot;);
    };
    let Ok(count) &#x3D; u64::from_str(count_str) else {
        panic!(&amp;quot;Can&#x27;t parse integer: &#x27;{count_str}&#x27;&amp;quot;);
    };
    (count, item)
}
assert_eq!(get_count_item(&amp;quot;3 chairs&amp;quot;), (3, &amp;quot;chairs&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The scope of name bindings is the main thing that makes this different from
&lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; expressions. You could previously approximate these
patterns with an unfortunate bit of repetition and an outer &lt;code&gt;let&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;    let (count_str, item) &#x3D; match (it.next(), it.next()) {
        (Some(count_str), Some(item)) &#x3D;&amp;gt; (count_str, item),
        _ &#x3D;&amp;gt; panic!(&amp;quot;Can&#x27;t segment count item pair: &#x27;{s}&#x27;&amp;quot;),
    };
    let count &#x3D; if let Ok(count) &#x3D; u64::from_str(count_str) {
        count
    } else {
        panic!(&amp;quot;Can&#x27;t parse integer: &#x27;{count_str}&#x27;&amp;quot;);
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#break-from-labeled-blocks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;break-from-labeled-blocks&quot;&gt;&lt;/a&gt;&lt;code&gt;break&lt;/code&gt; from labeled blocks&lt;/h3&gt;
&lt;p&gt;Plain block expressions can now be labeled as a &lt;code&gt;break&lt;/code&gt; target, terminating
that block early. This may sound a little like a &lt;code&gt;goto&lt;/code&gt; statement, but it&#x27;s not
an arbitrary jump, only from within a block to its end. This was already
possible with &lt;code&gt;loop&lt;/code&gt; blocks, and you may have seen people write loops that
always execute only once, just to get a labeled &lt;code&gt;break&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now there&#x27;s a language feature specifically for that! Labeled &lt;code&gt;break&lt;/code&gt; may also
include an expression value, just as with loops, letting a multi-statement
block have an early &amp;quot;return&amp;quot; value.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let result &#x3D; &#x27;block: {
    do_thing();
    if condition_not_met() {
        break &#x27;block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break &#x27;block 2;
    }
    do_last_thing();
    3
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#splitting-linux-debuginfo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;splitting-linux-debuginfo&quot;&gt;&lt;/a&gt;Splitting Linux debuginfo&lt;/h3&gt;
&lt;p&gt;Back in Rust 1.51, the compiler team added support for &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#splitting-debug-information&quot;&gt;split debug
information&lt;/a&gt;
on macOS, and now this option is stable for use on Linux as well.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;unpacked&lt;/code&gt; will split debuginfo out into multiple &lt;code&gt;.dwo&lt;/code&gt;
DWARF object files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;packed&lt;/code&gt; will produce a single &lt;code&gt;.dwp&lt;/code&gt; DWARF package
alongside your output binary with all the debuginfo packaged together.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;off&lt;/code&gt; is still the default behavior, which includes DWARF
data in &lt;code&gt;.debug_*&lt;/code&gt; ELF sections of the objects and final binary.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Split DWARF lets the linker avoid processing the debuginfo (because it isn&#x27;t in
the object files being linked anymore), which can speed up link times!&lt;/p&gt;
&lt;p&gt;Other targets now also accept &lt;code&gt;-Csplit-debuginfo&lt;/code&gt; as a stable option with their
platform-specific default value, but specifying other values is still unstable.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html&quot;&gt;&lt;code&gt;std::backtrace::Backtrace&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref&quot;&gt;&lt;code&gt;Bound::as_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html&quot;&gt;&lt;code&gt;std::io::read_to_string&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::cast_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::cast_const&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of particular note, the &lt;code&gt;Backtrace&lt;/code&gt; API allows capturing a stack backtrace at
any time, using the same platform-specific implementation that usually serves
panic backtraces. This may be useful for adding runtime context to error types,
for example.&lt;/p&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::offset_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::offset_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compatibility-notes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compatibility-notes&quot;&gt;&lt;/a&gt;Compatibility notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;As the final step of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html&quot;&gt;RLS
deprecation&lt;/a&gt;,
this release has replaced RLS with a small LSP server showing a deprecation
warning, advising users to migrate to &lt;code&gt;rust-analyzer&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.65 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MIR inlining is now enabled for optimized compilations. This provides a 3-10%
improvement in compiletimes for real world crates.&lt;/li&gt;
&lt;li&gt;When scheduling builds, Cargo now sorts the queue of pending jobs to improve performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-165-2022-11-03&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-165&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1650&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1650&quot;&gt;&lt;/a&gt;Contributors to 1.65.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.65.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.65.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Generic associated types to be stable in Rust 1.65</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html" type="text/html" title="Generic associated types to be stable in Rust 1.65" />
        <published>2022-10-28T00:00:00+00:00</published>
        <updated>2022-10-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/10/28/gats-stabilization.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">&lt;p&gt;As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable — over six and a half years after the original &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt; was opened. This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like &lt;code&gt;async&lt;/code&gt; or const generics, there are limitations in the initial stabilization that we plan to remove in the future.&lt;/p&gt;
&lt;p&gt;The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into. More detailed information can be found in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt;, in the &lt;a href&#x3D;&quot;https://rust-lang.github.io/generic-associated-types-initiative/index.html&quot;&gt;GATs initiative repository&lt;/a&gt;, in the previous &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;blog post&lt;/a&gt; during the start of the stabilization push, in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/items/associated-items.html&quot;&gt;associated items section in the nightly reference&lt;/a&gt;, or in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+is%3Aissue+label%3AF-generic_associated_types&quot;&gt;open issues on Github for GATs&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-gats&quot;&gt;&lt;/a&gt;What are GATs&lt;/h2&gt;
&lt;p&gt;At its core, generic associated types allow you to have &lt;em&gt;generics&lt;/em&gt; (type, lifetime, or const) on &lt;em&gt;associated types&lt;/em&gt;. Note that this is really just rounding out the places where you can put generics: for example, you can already have generics on freestanding type aliases and on functions in traits. Now you can just have generics on type aliases in traits (which we just call associated types). Here&#x27;s an example of what a trait with a GAT would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Self::Item&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most of this should look familiar; this trait looks &lt;em&gt;very&lt;/em&gt; similar to the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait from the standard library. Fundamentally, this version of the trait allows the &lt;code&gt;next&lt;/code&gt; function to return an item that &lt;em&gt;borrows&lt;/em&gt; from &lt;code&gt;self&lt;/code&gt;. For more detail about the example, as well as some info on what that &lt;code&gt;where Self: &#x27;a&lt;/code&gt; is for, check out the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In general, GATs provide a foundational basis for a vast range of patterns and APIs. If you really want to get a feel for how many projects have been blocked on GATs being stable, go scroll through either the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;tracking issue&lt;/a&gt;: you will find numerous issues from other projects linking to those threads over the years saying something along the lines of &amp;quot;we want the API to look like X, but for that we need GATs&amp;quot; (or see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/96709#issuecomment-1173170243&quot;&gt;this comment&lt;/a&gt; that has some of these put together already). If you&#x27;re interested in how GATs enable a library to do zero-copy parsing, resulting in nearly a ten-fold performance increase, you might be interested in checking out a &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2022/06/27/many-modes-a-gats-pattern/&quot;&gt;blog post&lt;/a&gt; on it by Niko Matsakis.&lt;/p&gt;
&lt;p&gt;All in all, even if &lt;em&gt;you&lt;/em&gt; won&#x27;t need to use GATs directly, it&#x27;s very possible that the &lt;em&gt;libraries&lt;/em&gt; you use will use GATs either internally or publically for ergonomics, performance, or just because that&#x27;s the only way the implementation works.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#when-gats-go-wrong---a-few-current-bugs-and-limitations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;when-gats-go-wrong---a-few-current-bugs-and-limitations&quot;&gt;&lt;/a&gt;When GATs go wrong - a few current bugs and limitations&lt;/h2&gt;
&lt;p&gt;As alluded to before, this stabilization is not without its bugs and limitations. This is not atypical compared to prior large language features. We plan to fix these bugs and remove these limitations as part of ongoing efforts driven by the newly-formed types team. (Stayed tuned for more details in an official announcement soon!)&lt;/p&gt;
&lt;p&gt;Here, we&#x27;ll go over just a couple of the limitations that we&#x27;ve identified that users might run into.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#implied-static-requirement-from-higher-ranked-trait-bounds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;implied-static-requirement-from-higher-ranked-trait-bounds&quot;&gt;&lt;/a&gt;Implied &lt;code&gt;&#x27;static&lt;/code&gt; requirement from higher-ranked trait bounds&lt;/h3&gt;
&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;
}

pub struct WindowsMut&amp;lt;&#x27;x, T&amp;gt; {
    slice: &amp;amp;&#x27;x mut [T],
}

impl&amp;lt;&#x27;x, T&amp;gt; LendingIterator for WindowsMut&amp;lt;&#x27;x, T&amp;gt; {
    type Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a mut [T] where Self: &#x27;a;
}

fn print_items&amp;lt;I&amp;gt;(iter: I)
where
    I: LendingIterator,
    for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug,
{ ... }

fn main() {
    let mut array &#x3D; [0; 16];
    let slice &#x3D; &amp;amp;mut array;
    let windows &#x3D; WindowsMut { slice };
    print_items::&amp;lt;WindowsMut&amp;lt;&#x27;_, usize&amp;gt;&amp;gt;(windows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, imagine we wanted to have a &lt;code&gt;LendingIterator&lt;/code&gt; where the items are overlapping slices of an array. We also have a function &lt;code&gt;print_items&lt;/code&gt; that prints every item of a &lt;code&gt;LendingIterator&lt;/code&gt;, as long as they implement &lt;code&gt;Debug&lt;/code&gt;. This all seems innocent enough, but the above code doesn&#x27;t compile — even though it should. Without going into details here, the &lt;code&gt;for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug&lt;/code&gt; currently implies that &lt;code&gt;I::Item&amp;lt;&#x27;a&amp;gt;&lt;/code&gt; must outlive &lt;code&gt;&#x27;static&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is not really a nice bug. And of all the ones we&#x27;ll mention today, this will likely be the one that is most limiting, annoying, and tough to figure out. This pops up much more often with GATs, but can be found with code that doesn&#x27;t use GATs at all. Unfortunately, fixing this requires some refactorings to the compiler that isn&#x27;t a short-term project. It is on the horizon though. The good news is that, in the meantime, we are working on improving the error message you get from this code. This is what it will look like in the upcoming stabilization:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0597]: &#x60;array&#x60; does not live long enough
   |
   |     let slice &#x3D; &amp;amp;mut array;
   |                 ^^^^^^^^^^ borrowed value does not live long enough
   |     let windows &#x3D; WindowsMut { slice };
   |     print_items::&amp;lt;WindowsMut&amp;lt;&#x27;_, usize&amp;gt;&amp;gt;(windows);
   |     -------------------------------------------- argument requires that &#x60;array&#x60; is borrowed for &#x60;&#x27;static&#x60;
   | }
   | - &#x60;array&#x60; dropped here while still borrowed
   |
note: due to current limitations in the borrow checker, this implies a &#x60;&#x27;static&#x60; lifetime
   |
   |     for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug,
   |                          ^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#x27;s not perfect, but it&#x27;s something. It might not cover all cases, but if have a &lt;code&gt;for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Trait&lt;/code&gt; bound somewhere and get an error that says something doesn&#x27;t live long enough, you might be running into this bug. We&#x27;re actively working to fix this. However, this error doesn&#x27;t actually come up as often as you might expect while reading this (from our experience), so we feel the feature is still immensely useful enough even with it around.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#traits-with-gats-are-not-object-safe&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;traits-with-gats-are-not-object-safe&quot;&gt;&lt;/a&gt;Traits with GATs are not object safe&lt;/h3&gt;
&lt;p&gt;So, this one is a simple one. Making traits with GATs object safe is going to take a little bit of design work for its implementation. To get an idea of the work left to do here, let&#x27;s start with a bit of code that you could write on stable today:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn takes_iter(_: &amp;amp;dyn Iterator) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, you can write this, but it doesn&#x27;t compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0191]: the value of the associated type &#x60;Item&#x60; (from trait &#x60;Iterator&#x60;) must be specified
 --&amp;gt; src/lib.rs:1:23
  |
1 | fn takes_iter(_: &amp;amp;dyn Iterator) {}
  |                       ^^^^^^^^ help: specify the associated type: &#x60;Iterator&amp;lt;Item &#x3D; Type&amp;gt;&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a trait object to be well-formed, it must specify a value for all associated types. For the same reason, we don&#x27;t want to accept the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn no_associated_type(_: &amp;amp;dyn LendingIterator) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, GATs introduce an extra bit of complexity. Take this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn not_fully_generic(_: &amp;amp;dyn LendingIterator&amp;lt;Item&amp;lt;&#x27;static&amp;gt; &#x3D; &amp;amp;&#x27;static str&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, we&#x27;ve specified the value of the associated type for &lt;em&gt;one&lt;/em&gt; value of of the &lt;code&gt;Item&lt;/code&gt;&#x27;s lifetime (&lt;code&gt;&#x27;static&lt;/code&gt;), but not for &lt;em&gt;any&lt;/em&gt; value, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn fully_generic(_: &amp;amp;dyn for&amp;lt;&#x27;a&amp;gt; LendingIterator&amp;lt;Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a str&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While we have a solid idea of how to implement requirement in some &lt;em&gt;future&lt;/em&gt; iterations of the trait solver (that uses more logical formulations), implementing it in the current trait solver is more difficult. Thus, we&#x27;ve chosen to hold off on this for now.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#the-borrow-checker-isnt-perfect-and-it-shows&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-borrow-checker-isnt-perfect-and-it-shows&quot;&gt;&lt;/a&gt;The borrow checker isn&#x27;t perfect and it shows&lt;/h3&gt;
&lt;p&gt;Keeping with the &lt;code&gt;LendingIterator&lt;/code&gt; example, let&#x27;s start by looking at two methods on &lt;code&gt;Iterator&lt;/code&gt;: &lt;code&gt;for_each&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Iterator {
    type Item;

    fn for_each&amp;lt;F&amp;gt;(self, f: F)
    where
        Self: Sized,
        F: FnMut(Self::Item);
    
    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
    where
        Self: Sized,
        P: FnMut(&amp;amp;Self::Item) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of these take a function as an argument. Closures are often used these. Now, let&#x27;s look at the &lt;code&gt;LendingIterator&lt;/code&gt; definitions:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn for_each&amp;lt;F&amp;gt;(mut self, mut f: F)
    where
        Self: Sized,
        F: FnMut(Self::Item&amp;lt;&#x27;_&amp;gt;);

    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
    where
        Self: Sized,
        P: FnMut(&amp;amp;Self::Item&amp;lt;&#x27;_&amp;gt;) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks simple enough, but if it really was, would it be here? Let&#x27;s start by looking at what happens when we try to use &lt;code&gt;for_each&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn iterate&amp;lt;T, I: for&amp;lt;&#x27;a&amp;gt; LendingIterator&amp;lt;Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a T&amp;gt;&amp;gt;(iter: I) {
    iter.for_each(|_: &amp;amp;T| {})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error: &#x60;I&#x60; does not live long enough
   |
   |     iter.for_each(|_: &amp;amp;T| {})
   |                   ^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, that isn&#x27;t great. Turns out, this is pretty closely related to the first limitation we talked about earlier, even
though the borrow checker does play a role here.&lt;/p&gt;
&lt;p&gt;On the other hand, let&#x27;s look at something that&#x27;s very clearly a borrow checker problem, by looking at an implementation
of the &lt;code&gt;Filter&lt;/code&gt; struct returned by the &lt;code&gt;filter&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl&amp;lt;I: LendingIterator, P&amp;gt; LendingIterator for Filter&amp;lt;I, P&amp;gt;
where
    P: FnMut(&amp;amp;I::Item&amp;lt;&#x27;_&amp;gt;) -&amp;gt; bool, // &amp;lt;- the bound from above, a function
{
    type Item&amp;lt;&#x27;a&amp;gt; &#x3D; I::Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a; // &amp;lt;- Use the underlying type

    fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;I::Item&amp;lt;&#x27;_&amp;gt;&amp;gt; {
        // Loop through each item in the underlying &#x60;LendingIterator&#x60;...
        while let Some(item) &#x3D; self.iter.next() {
            // ...check if the predicate holds for the item...
            if (self.predicate)(&amp;amp;item) {
                // ...and return it if it does
                return Some(item);
            }
        }
        // Return &#x60;None&#x60; when we&#x27;re out of items
        return None;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, the implementation here shouldn&#x27;t seem surprising. We, of course, run into a borrow checker error:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0499]: cannot borrow &#x60;self.iter&#x60; as mutable more than once at a time
  --&amp;gt; src/main.rs:28:32
   |
27 |     fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;I::Item&amp;lt;&#x27;_&amp;gt;&amp;gt; {
   |             - let&#x27;s call the lifetime of this reference &#x60;&#x27;1&#x60;
28 |         while let Some(item) &#x3D; self.iter.next() {
   |                                ^^^^^^^^^^^^^^^^ &#x60;self.iter&#x60; was mutably borrowed here in the previous iteration of the loop
29 |             if (self.predicate)(&amp;amp;item) {
30 |                 return Some(item);
   |                        ---------- returning this value requires that &#x60;self.iter&#x60; is borrowed for &#x60;&#x27;1&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a known limitation in the current borrow checker and should be solved in some future iteration (like &lt;a href&#x3D;&quot;https://github.com/rust-lang/polonius&quot;&gt;Polonius&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#non-local-requirements-for-where-clauses-on-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;non-local-requirements-for-where-clauses-on-gats&quot;&gt;&lt;/a&gt;Non-local requirements for where clauses on GATs&lt;/h3&gt;
&lt;p&gt;The last limitation we&#x27;ll talk about today is a bit different than the others; it&#x27;s not a bug and it shouldn&#x27;t prevent any programs from compiling. But it all comes back to that &lt;code&gt;where Self: &#x27;a&lt;/code&gt; clause you&#x27;ve seen in several parts of this post. As mentioned before, if you&#x27;re interested in digging a bit into why that clause is required, see the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There is one not-so-ideal requirement about this clause: you must write it on the trait. Like with where clauses on functions, you cannot add clauses to associated types in impls that aren&#x27;t there in the trait. However, if you &lt;em&gt;didn&#x27;t&lt;/em&gt; add this clause, a large set of potential impls of the trait would be disallowed.&lt;/p&gt;
&lt;p&gt;To help users not fall into the pitfall of accidentally forgetting to add this (or similar clauses that end up with the same effect for a different set of generics), we&#x27;ve implemented a set of rules that must be followed for a trait with GATs to compile. Let&#x27;s first look at the error without writing the clause:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt;;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Self::Item&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error: missing required bound on &#x60;Item&#x60;
 --&amp;gt; src/lib.rs:2:5
  |
2 |     type Item&amp;lt;&#x27;a&amp;gt;;
  |     ^^^^^^^^^^^^^-
  |                  |
  |                  help: add the required where clause: &#x60;where Self: &#x27;a&#x60;
  |
  &#x3D; note: this bound is currently required to ensure that impls have maximum flexibility
  &#x3D; note: we are soliciting feedback, see issue #87479 &amp;lt;https://github.com/rust-lang/rust/issues/87479&amp;gt; for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error should hopefully be helpful (you can even &lt;code&gt;cargo fix&lt;/code&gt; it!). But, what exactly are these rules? Well, ultimately, they end up being somewhat simple: &lt;em&gt;for methods that use the GAT, any bounds that can be proven must also be present on the GAT itself&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Okay, so how did we end up with the required &lt;code&gt;Self: &#x27;a&lt;/code&gt; bound. Well, let&#x27;s take a look at the &lt;code&gt;next&lt;/code&gt; method. It returns &lt;code&gt;Self::Item&amp;lt;&#x27;a&amp;gt;&lt;/code&gt;, and we have an argument &lt;code&gt;&amp;amp;&#x27;a mut self&lt;/code&gt;. We&#x27;re getting a bit into the details of the Rust language, but because of that argument, we know that &lt;code&gt;Self: &#x27;a&lt;/code&gt; must hold. So, we require that bound.&lt;/p&gt;
&lt;p&gt;We&#x27;re requiring these bounds now to leave room in the future to potentially imply these automatically (and of course because it should help users write traits with GATs). They shouldn&#x27;t interfere with any real use-cases, but if you do encounter a problem, check out the issue mentioned in the error above. And if you want to see a fairly comprehensive testing of different scenarios on what bounds are required and when, check out the relevant &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/f2702e922ba31e49d6167f5651d4545646dcf22d/src/test/ui/generic-associated-types/self-outlives-lint.rs&quot;&gt;test file&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully the limitations brought up here and explanations thereof don&#x27;t detract from overall excitement of GATs stabilization. Sure, these limitations do, well, &lt;em&gt;limit&lt;/em&gt; the number of things you can do with GATs. &lt;em&gt;However&lt;/em&gt;, we would not be stabilizing GATs if we didn&#x27;t feel that GATs are not still &lt;em&gt;very&lt;/em&gt; useful. Additionally, we wouldn&#x27;t be stabilizing GATs if we didn&#x27;t feel that the limitations weren&#x27;t solvable (and in a backwards-compatible manner).&lt;/p&gt;
&lt;p&gt;To conclude things, all the various people involved in getting this stabilization to happen deserve the utmost thanks. As said before, it&#x27;s been 6.5 years coming and it couldn&#x27;t have happened without everyone&#x27;s support and dedication. Thanks all!&lt;/p&gt;
</content>

        <author>
            <name>Jack Huey</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.64.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html" type="text/html" title="Announcing Rust 1.64.0" />
        <published>2022-09-22T00:00:00+00:00</published>
        <updated>2022-09-22T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.64.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.64.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;detailed release notes for
1.64.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1640-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1640-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.64.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#enhancing-await-with-intofuture&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;enhancing-await-with-intofuture&quot;&gt;&lt;/a&gt;Enhancing &lt;code&gt;.await&lt;/code&gt; with &lt;code&gt;IntoFuture&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Rust 1.64 stabilizes the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/a&gt;
trait. &lt;code&gt;IntoFuture&lt;/code&gt; is a trait similar to
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;,
but rather than supporting &lt;code&gt;for ... in ...&lt;/code&gt; loops, &lt;code&gt;IntoFuture&lt;/code&gt; changes how
&lt;code&gt;.await&lt;/code&gt; works. With &lt;code&gt;IntoFuture&lt;/code&gt;, the &lt;code&gt;.await&lt;/code&gt; keyword can await more than
just futures; it can await &lt;em&gt;anything which can be converted into a &lt;code&gt;Future&lt;/code&gt; via
&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/em&gt; - which can help make your APIs more user-friendly!&lt;/p&gt;
&lt;p&gt;Take for example a builder which constructs requests to some storage provider
over the network:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical usage would likely look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .send()                           // 3. construct the future
    .await?;                          // 4. run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not bad, but we can do better here. Using &lt;code&gt;IntoFuture&lt;/code&gt; we can combine
&lt;em&gt;&amp;quot;construct the future&amp;quot;&lt;/em&gt; (line 3) and &lt;em&gt;&amp;quot;run the future&amp;quot;&lt;/em&gt; (line 4) into a single
step:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .await?;                          // 3. construct + run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do this by implementing &lt;code&gt;IntoFuture&lt;/code&gt; for &lt;code&gt;StorageRequest&lt;/code&gt;. &lt;code&gt;IntoFuture&lt;/code&gt;
requires us to have a named future we can return, which we can do by creating a
&amp;quot;boxed future&amp;quot; and defining a type alias for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// First we must import some new types into the scope.
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}

// The new implementations:
// 1. create a new named future type
// 2. implement &#x60;IntoFuture&#x60; for &#x60;StorageRequest&#x60;
pub type StorageRequestFuture &#x3D; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output &#x3D; Result&amp;lt;StorageResponse, Error&amp;gt;&amp;gt; + Send + &#x27;static&amp;gt;&amp;gt;
impl IntoFuture for StorageRequest {
    type IntoFuture &#x3D; StorageRequestFuture;
    type Output &#x3D; &amp;lt;StorageRequestFuture as Future&amp;gt;::Output;
    fn into_future(self) -&amp;gt; Self::IntoFuture {
        Box::pin(self.send())
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes a bit more code to implement, but provides a simpler API for users.&lt;/p&gt;
&lt;p&gt;In the future, the Rust Async WG hopes to simplify the creating new named
futures by supporting &lt;a href&#x3D;&quot;https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt; in &lt;code&gt;type&lt;/code&gt; aliases (Type Alias Impl Trait or
TAIT)&lt;/a&gt;.
This should make implementing &lt;code&gt;IntoFuture&lt;/code&gt; easier by simplifying the type
alias&#x27; signature, and make it more performant by removing the &lt;code&gt;Box&lt;/code&gt; from the
type alias.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#c-compatible-ffi-types-in-core-and-alloc&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;c-compatible-ffi-types-in-core-and-alloc&quot;&gt;&lt;/a&gt;C-compatible FFI types in core and alloc&lt;/h3&gt;
&lt;p&gt;When calling or being called by C ABIs, Rust code can use type aliases like
&lt;code&gt;c_uint&lt;/code&gt; or &lt;code&gt;c_ulong&lt;/code&gt; to match the corresponding types from C on any target,
without requiring target-specific code or conditionals.&lt;/p&gt;
&lt;p&gt;Previously, these type aliases were only available in &lt;code&gt;std&lt;/code&gt;, so code written
for embedded targets and other scenarios that could only use &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;alloc&lt;/code&gt;
could not use these types.&lt;/p&gt;
&lt;p&gt;Rust 1.64 now provides all of the &lt;code&gt;c_*&lt;/code&gt; type aliases in
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/index.html&quot;&gt;&lt;code&gt;core::ffi&lt;/code&gt;&lt;/a&gt;, as well as
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt; for
working with C strings. Rust 1.64 also provides
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;
for working with owned C strings using only the &lt;code&gt;alloc&lt;/code&gt; crate, rather than the
full &lt;code&gt;std&lt;/code&gt; library.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-analyzer-is-now-available-via-rustup&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-analyzer-is-now-available-via-rustup&quot;&gt;&lt;/a&gt;rust-analyzer is now available via rustup&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://rust-analyzer.github.io/&quot;&gt;rust-analyzer&lt;/a&gt; is now included as part of
the collection of tools included with Rust. This makes it easier to download
and access rust-analyzer, and makes it available on more platforms. It is
available as a &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/concepts/components.html&quot;&gt;rustup
component&lt;/a&gt; which
can be installed with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup component add rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this time, to run the rustup-installed version, you need to invoke it this
way:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup run stable rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next release of rustup will provide a built-in proxy so that running the
executable &lt;code&gt;rust-analyzer&lt;/code&gt; will launch the appropriate version.&lt;/p&gt;
&lt;p&gt;Most users should continue to use the releases provided by the rust-analyzer
team (available on the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-analyzer/releases&quot;&gt;rust-analyzer releases
page&lt;/a&gt;), which are
published more frequently. Users of the &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/items?itemName&#x3D;rust-lang.rust-analyzer&quot;&gt;official VSCode
extension&lt;/a&gt;
are not affected since it automatically downloads and updates releases in the
background.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-improvements-workspace-inheritance-and-multi-target-builds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-improvements-workspace-inheritance-and-multi-target-builds&quot;&gt;&lt;/a&gt;Cargo improvements: workspace inheritance and multi-target builds&lt;/h3&gt;
&lt;p&gt;When working with collections of related libraries or binary crates in one
Cargo workspace, you can now avoid duplication of common field values between
crates, such as common version numbers, repository URLs, or &lt;code&gt;rust-version&lt;/code&gt;.
This also helps keep these values in sync between crates when updating them.
For more details, see
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;&lt;code&gt;workspace.package&lt;/code&gt;&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table&quot;&gt;&lt;code&gt;workspace.dependencies&lt;/code&gt;&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace&quot;&gt;&amp;quot;inheriting a dependency from a
workspace&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When building for multiple targets, you can now pass multiple &lt;code&gt;--target&lt;/code&gt;
options to &lt;code&gt;cargo build&lt;/code&gt;, to build all of those targets at once. You can also
set
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html#buildtarget&quot;&gt;&lt;code&gt;build.target&lt;/code&gt;&lt;/a&gt;
to an array of multiple targets in &lt;code&gt;.cargo/config.toml&lt;/code&gt; to build for multiple
targets by default.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;future::IntoFuture&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul&quot;&gt;&lt;code&gt;num::NonZero*::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow&quot;&gt;&lt;code&gt;num::NonZero*::checked_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul&quot;&gt;&lt;code&gt;num::NonZero*::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow&quot;&gt;&lt;code&gt;num::NonZero*::saturating_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs&quot;&gt;&lt;code&gt;num::NonZeroI*::abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::checked_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::overflowing_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::saturating_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::unsigned_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::wrapping_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_next_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add&quot;&gt;&lt;code&gt;num::NonZeroU*::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group&quot;&gt;&lt;code&gt;os::unix::process::CommandExt::process_group&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_dir&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_file&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::ffi&lt;/code&gt;, but are now also available in
&lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html&quot;&gt;&lt;code&gt;core::ffi::FromBytesWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html&quot;&gt;&lt;code&gt;alloc::ffi::FromVecWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html&quot;&gt;&lt;code&gt;alloc::ffi::IntoStringError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html&quot;&gt;&lt;code&gt;alloc::ffi::NulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::os::raw&lt;/code&gt;, but are now also
available in &lt;code&gt;core::ffi&lt;/code&gt; and &lt;code&gt;std::ffi&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_char.html&quot;&gt;&lt;code&gt;ffi::c_char&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_double.html&quot;&gt;&lt;code&gt;ffi::c_double&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_float.html&quot;&gt;&lt;code&gt;ffi::c_float&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_int.html&quot;&gt;&lt;code&gt;ffi::c_int&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_long.html&quot;&gt;&lt;code&gt;ffi::c_long&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html&quot;&gt;&lt;code&gt;ffi::c_longlong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html&quot;&gt;&lt;code&gt;ffi::c_schar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_short.html&quot;&gt;&lt;code&gt;ffi::c_short&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html&quot;&gt;&lt;code&gt;ffi::c_uchar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html&quot;&gt;&lt;code&gt;ffi::c_uint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html&quot;&gt;&lt;code&gt;ffi::c_ulong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html&quot;&gt;&lt;code&gt;ffi::c_ulonglong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html&quot;&gt;&lt;code&gt;ffi::c_ushort&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;ve stabilized some helpers for use with &lt;code&gt;Poll&lt;/code&gt;, the low-level implementation
underneath futures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html&quot;&gt;&lt;code&gt;future::poll_fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/macro.ready.html&quot;&gt;&lt;code&gt;task::ready!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future, we hope to provide simpler APIs that require less use of
low-level details like &lt;code&gt;Poll&lt;/code&gt; and &lt;code&gt;Pin&lt;/code&gt;, but in the meantime, these helpers
make it easier to write such code.&lt;/p&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compatibility-notes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compatibility-notes&quot;&gt;&lt;/a&gt;Compatibility notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;As &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html&quot;&gt;previously
announced&lt;/a&gt;,
&lt;code&gt;linux&lt;/code&gt; targets now require at least Linux kernel 3.2 (except for targets which
already required a newer kernel), and &lt;code&gt;linux-gnu&lt;/code&gt; targets now require glibc
2.17 (except for targets which already required a newer glibc).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rust 1.64.0 changes the memory layout of &lt;code&gt;Ipv4Addr&lt;/code&gt;, &lt;code&gt;Ipv6Addr&lt;/code&gt;,
&lt;code&gt;SocketAddrV4&lt;/code&gt; and &lt;code&gt;SocketAddrV6&lt;/code&gt; to be more compact and memory efficient.
This internal representation was never exposed, but some crates relied on
it anyway by using &lt;code&gt;std::mem::transmute&lt;/code&gt;, resulting in invalid memory
accesses. Such internal implementation details of the standard library are
&lt;em&gt;never&lt;/em&gt; considered a stable interface. To limit the damage, we worked with
the authors of all of the still-maintained crates doing so to release fixed
versions, which have been out for more than a year. The vast majority of
impacted users should be able to mitigate with a &lt;code&gt;cargo update&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As part of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html&quot;&gt;RLS
deprecation&lt;/a&gt;,
this is also the last release containing a copy of RLS. Starting from Rust
1.65.0, RLS will be replaced by a small LSP server showing the deprecation
warning.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.64 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows builds of the Rust compiler now use profile-guided optimization,
providing performance improvements of 10-20% for compiling Rust code on
Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you define a struct containing fields that are never used, rustc will warn
about the unused fields. Now, in Rust 1.64, you can enable the
&lt;code&gt;unused_tuple_struct_fields&lt;/code&gt; lint to get the same warnings about unused
fields in a tuple struct. In future versions, we plan to make this lint
warn by default.  Fields of type unit (&lt;code&gt;()&lt;/code&gt;) do not produce this warning,
to make it easier to migrate existing code without having to change tuple
indices.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-164-2022-09-22&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-164&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1640&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1640&quot;&gt;&lt;/a&gt;Contributors to 1.64.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.64.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.64.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Const Eval (Un)Safety Rules</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html" type="text/html" title="Const Eval (Un)Safety Rules" />
        <published>2022-09-15T00:00:00+00:00</published>
        <updated>2022-09-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html">&lt;p&gt;In a recent Rust issue (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt;), a developer noted that the upcoming
1.64-beta version of Rust had started signalling errors on their crate,
&lt;a href&#x3D;&quot;https://github.com/unicode-org/icu4x&quot;&gt;&lt;code&gt;icu4x&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;icu4x&lt;/code&gt; crate uses unsafe code during const evaluation.
&lt;em&gt;Const evaluation&lt;/em&gt;, or just &amp;quot;const-eval&amp;quot;,
runs at compile-time but produces values that may end up embedded in the
final object code that executes at runtime.&lt;/p&gt;
&lt;p&gt;Rust&#x27;s const-eval system supports both safe and unsafe Rust, but the rules for
what unsafe code is allowed to do during const-eval are even more strict than
what is allowed for unsafe code at runtime. This post is going to go into detail
about one of those rules.&lt;/p&gt;
&lt;p&gt;(Note: If your &lt;code&gt;const&lt;/code&gt; code does not use any &lt;code&gt;unsafe&lt;/code&gt; blocks or call any &lt;code&gt;const fn&lt;/code&gt;
with an &lt;code&gt;unsafe&lt;/code&gt; block, then you do not need to worry about this!)&lt;/p&gt;
&lt;!--

(This is distinct from procedural macros, which are Rust code that runs at
compile-time to manipulate *program syntax*; syntactic values are not usually
embedded into the final object code.)

--&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-new-diagnostic-to-watch-for&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-new-diagnostic-to-watch-for&quot;&gt;&lt;/a&gt;A new diagnostic to watch for&lt;/h2&gt;
&lt;p&gt;The problem, reduced over the course of the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923#issuecomment-1200284482&quot;&gt;comment thread of #99923&lt;/a&gt;, is that certain static initialization expressions (see below) are
defined as having undefined behavior (UB) &lt;em&gt;at compile time&lt;/em&gt; (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;beta&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;67a917fc4f2a4bf2eb72aebf8dad0fe9&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _copy &#x3D; illegal_ptr2int;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Many thanks to &lt;code&gt;@eddyb&lt;/code&gt; for the minimal reproduction!)&lt;/p&gt;
&lt;p&gt;The code above was accepted by Rust versions 1.63 and earlier, but in the Rust
1.64-beta, it now causes a compile time error with the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:3:17
  |
3 |     let _copy &#x3D; illegal_ptr2int;
  |                 ^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the message says, this operation is not supported: the &lt;code&gt;transmute&lt;/code&gt;
above is trying to reinterpret the memory address &lt;code&gt;&amp;amp;()&lt;/code&gt; as an integer of type
&lt;code&gt;usize&lt;/code&gt;. The compiler cannot predict what memory address the &lt;code&gt;()&lt;/code&gt; would be
associated with at execution time, so it refuses to allow that reinterpretation.&lt;/p&gt;
&lt;p&gt;When you write safe Rust, then the compiler is responsible for preventing
undefined behavior. When you write any unsafe code (be it const or non-const),
you are responsible for preventing UB, and during const-eval, the rules about
what unsafe code has defined behavior are even more strict than the analogous
rules governing Rust&#x27;s runtime semantics. (In other words, &lt;em&gt;more&lt;/em&gt; code is
classified as &amp;quot;UB&amp;quot; than you may have otherwise realized.)&lt;/p&gt;
&lt;p&gt;If you hit undefined behavior during const-eval, the Rust compiler will protect
itself from &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;adverse effects&lt;/a&gt; such as the undefined
behavior leaking into the type system, but there are few guarantees
other than that. For example, compile-time UB could lead to runtime UB.
Furthermore, if you have UB at const-eval time, there is no guarantee that your
code will be accepted from one compiler version to another.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-new-here&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-new-here&quot;&gt;&lt;/a&gt;What is new here&lt;/h2&gt;
&lt;p&gt;You might be thinking: &amp;quot;it &lt;em&gt;used to be&lt;/em&gt; accepted; therefore, there must be some
value for the memory address that the previous version of the compiler was using
here.&amp;quot;&lt;/p&gt;
&lt;p&gt;But such reasoning would be based on an imprecise view of what the Rust compiler
was doing here.&lt;/p&gt;
&lt;p&gt;The const-eval machinery of the Rust compiler  (also known as &amp;quot;the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/const-eval.html&quot;&gt;CTFE&lt;/a&gt; engine&amp;quot;)
is built upon a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/mir/index.html&quot;&gt;MIR&lt;/a&gt; interpreter which uses an &lt;em&gt;abstract model&lt;/em&gt; of a hypothetical machine as the
foundation for evaluating such expressions. This abstract model doesn&#x27;t have to
represent memory addresses as mere integers; in fact, to support
fine-grained checking for UB, it uses a much richer datatype for
the values that are held in the abstract memory store.&lt;/p&gt;
&lt;p&gt;(The aforementioned MIR interpreter is also the basis for &lt;a href&#x3D;&quot;https://github.com/rust-lang/miri#readme&quot;&gt;Miri&lt;/a&gt;, a research
tool that interprets &lt;em&gt;non-const&lt;/em&gt; Rust code, with a focus on
explicit detection of undefined behavior. The Miri developers are the primary
contributors to the CTFE engine in the Rust compiler.)&lt;/p&gt;
&lt;p&gt;The details of the CTFE engine&#x27;s value representation do not matter too much for our
discussion here. We merely note that earlier versions of the compiler silently
accepted expressions that &lt;em&gt;seemed to&lt;/em&gt; transmute memory addresses into integers,
copied them around, and then transmuted them back into addresses; but that was
not what was acutally happening under the hood. Instead, what was happening was
that the values were passed around blindly (after all, the whole point of
transmute is that it does no transformation on its input value, so it is a no-op
in terms of its operational semantics).&lt;/p&gt;
&lt;p&gt;The fact that it was passing a memory address into a context where you would
expect there to always be an integer value would only be caught, if at all, at
some later point.&lt;/p&gt;
&lt;p&gt;For example, the const-eval machinery rejects code that attempts to embed the
transmuted pointer into a value that could be used by runtime code, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;48456e8bd028c6aa5c80a1962d7e4fb8&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: usize &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    illegal_ptr2int
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Likewise, it rejects code that attempts to &lt;em&gt;perform arithmetic&lt;/em&gt; on that
non-integer value, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;74a35dd6ff93c86bd38c1a0006f2fc41&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _incremented &#x3D; illegal_ptr2int + 1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the latter two variants are rejected in stable Rust, and have been for
as long as Rust has accepted pointer-to-integer conversions in static
initializers (see e.g. Rust 1.52).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#more-similar-than-different&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-similar-than-different&quot;&gt;&lt;/a&gt;More similar than different&lt;/h2&gt;
&lt;p&gt;In fact, &lt;em&gt;all&lt;/em&gt; of the examples provided above are exhibiting &lt;em&gt;undefined
behavior&lt;/em&gt; according to the semantics of Rust&#x27;s const-eval system.&lt;/p&gt;
&lt;p&gt;The first example with &lt;code&gt;_copy&lt;/code&gt; was accepted in Rust versions 1.46 through 1.63
because of CTFE implementation artifacts. The CTFE engine puts considerable effort into
detecting UB, but does not catch all instances of it. Furthermore, by default,
such detection can be delayed to a point far after where the actual
problematic expression is found.&lt;/p&gt;
&lt;p&gt;But with nightly Rust, we can opt into extra checks for UB that the engine provides,
by passing the unstable flag &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt;. If we do that, then for
&lt;em&gt;all&lt;/em&gt; of the above examples we get the same result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:2:34
  |
2 |     let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The earlier examples had diagnostic output that put the blame in a misleading
place. With the more precise checking &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; enabled, the
compiler highlights the expression where we can first witness UB: the original
transmute itself! (Which was stated at the outset of this post; here we are just
pointing out that these tools can pinpoint the injection point more precisely.)&lt;/p&gt;
&lt;p&gt;Why not have these extra const-ub checks on by default? Well, the checks
introduce performance overhead upon Rust compilation time, and we do not know if
that overhead can be made acceptable. (However, &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bsteering.20meeting.5D.202022-09-02.20const-eval.20and.20future-compa.2E.2E.2E/near/296853344&quot;&gt;recent debate&lt;/a&gt;
among Miri developers indicates that the inherent cost here might not be as bad
as they had originally thought. Perhaps a future version of the compiler will
have these extra checks on by default.)&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#change-is-hard&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;change-is-hard&quot;&gt;&lt;/a&gt;Change is hard&lt;/h2&gt;
&lt;p&gt;You might well be wondering at this point: &amp;quot;Wait, when &lt;em&gt;is&lt;/em&gt; it okay to transmute
a pointer to a &lt;code&gt;usize&lt;/code&gt; during const evaluation?&amp;quot; And the answer is simple:
&amp;quot;Never.&amp;quot;&lt;/p&gt;
&lt;p&gt;Transmuting a pointer to a usize during const-eval has always been undefined behavior,
ever since const-eval added support for
&lt;code&gt;transmute&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt;. You can read more about this in the
&lt;code&gt;const_fn_transmute&lt;/code&gt; / &lt;code&gt;const_fn_union&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/85769#issuecomment-854363720&quot;&gt;stabilization report&lt;/a&gt;,
specifically the subsection entitled &amp;quot;Pointer-integer-transmutes&amp;quot;.
(It is also mentioned in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/mem/fn.transmute.html&quot;&gt;documentation&lt;/a&gt; for &lt;code&gt;transmute&lt;/code&gt;&lt;!--,
though with less discussion than what you see in the stabilization report --&gt;.)&lt;/p&gt;
&lt;p&gt;Thus, we can see that the classification of the above examples as UB during const evaluation
is not a new thing at all. The only change here was that the CTFE engine had some internal
changes that made it start detecting the UB rather than silently ignoring it.&lt;/p&gt;
&lt;p&gt;This means the Rust compiler has a shifting notion of what UB it will
explicitly catch. We anticipated this: RFC 3016, &amp;quot;const UB&amp;quot;, explicitly
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;says&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] there is no guarantee that UB is reliably detected during CTFE. This can
change from compiler version to compiler version: CTFE code that causes UB
could build fine with one compiler and fail to build with another. (This is in
accordance with the general policy that unsound code is not subject to
stability guarantees.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Having said that: So much of Rust&#x27;s success has been built around the trust that
we have earned with our community. Yes, the project has always reserved the
right to make breaking changes when resolving soundness bugs; but we have also
strived to mitigate such breakage &lt;em&gt;whenever feasible&lt;/em&gt;, via things like
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/lints/index.html#future-incompatible-lints&quot;&gt;future-incompatible lints&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today, with our current const-eval architecture, it is not
feasible to ensure that changes such as the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/97684&quot;&gt;one that injected&lt;/a&gt; issue
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; go through a future-incompat warning cycle.
The compiler team plans to keep our eye on issues in this space. If we see
evidence that these kinds of changes do cause breakage to a non-trivial number
of crates, then we will investigate further how we might smooth the transition
path between compiler releases. However, we need to balance any such goal
against the fact that Miri has very a limited set of developers: the researchers
determining how to define the semantics of unsafe languages like Rust. We do not
want to slow their work down!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-you-can-do-for-safetys-sake&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-you-can-do-for-safetys-sake&quot;&gt;&lt;/a&gt;What you can do for safety&#x27;s sake&lt;/h2&gt;
&lt;p&gt;If you observe the &lt;code&gt;could not evaluate static initializer&lt;/code&gt; message on your crate
atop Rust 1.64, and it was compiling with previous versions of Rust, we want you
to let us know: &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;file an issue&lt;/a&gt;!&lt;/p&gt;
&lt;!--

(Of course we always want to hear about such cases where a crate regresses
between Rust releases; this is just a case that was particularly subtle for us
to tease apart within the project community itself.)

--&gt;
&lt;p&gt;We have &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/100327#issuecomment-1214457275&quot;&gt;performed&lt;/a&gt; a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/tests/crater.html&quot;&gt;crater run&lt;/a&gt; for the 1.64-beta and that did not find any other
instances of this particular problem.
If you can test compiling your crate atop the 1.64-beta before the stable
release goes out on September 22nd, all the better! One easy way to try the beta
is to use &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand&quot;&gt;rustup&#x27;s override shortand&lt;/a&gt; for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&quot;&gt;$ rustup update beta
$ cargo +beta build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As Rust&#x27;s const-eval evolves, we may see another case like this arise again. If
you want to defend against future instances of const-eval UB, we recommend that
you set up a continuous integration service to invoke the nightly &lt;code&gt;rustc&lt;/code&gt; with
the unstable &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; flag on your code.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#want-to-help&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;want-to-help&quot;&gt;&lt;/a&gt;Want to help?&lt;/h2&gt;
&lt;p&gt;As you might imagine, a lot of us are pretty interested in questions such as
&amp;quot;what should be undefined behavior?&amp;quot;&lt;/p&gt;
&lt;p&gt;See for example Ralf Jung&#x27;s excellent blog series on why pointers are
complicated (parts &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html&quot;&gt;I&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2020/12/14/provenance.html&quot;&gt;II&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html&quot;&gt;III&lt;/a&gt;), which contain some of
the details elided above about the representation of pointer values, and spell out reasons why
you might want to be concerned about pointer-to-usize transmutes even &lt;em&gt;outside&lt;/em&gt;
of const-eval.&lt;/p&gt;
&lt;p&gt;If you are interested in trying to help us figure out answers to those kinds of
questions, please join us in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines&quot;&gt;unsafe code guidelines zulip&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in learning more about Miri, or contributing to it, you
can say Hello in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/269128-miri&quot;&gt;miri zulip&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To sum it all up: When you write safe Rust, then the compiler is responsible for
preventing undefined behavior. When you write any unsafe code, &lt;em&gt;you&lt;/em&gt; are
responsible for preventing undefined behavior. Rust&#x27;s const-eval system has a
stricter set of rules governing what unsafe code has defined behavior:
specifically, reinterpreting (aka &amp;quot;transmuting&amp;quot;) a pointer value as a &lt;code&gt;usize&lt;/code&gt; is
undefined behavior during const-eval. If you have undefined behavior at
const-eval time, there is no guarantee that your code will be accepted from one
compiler version to another.&lt;/p&gt;
&lt;p&gt;The compiler team is hoping that issue &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; is an exceptional fluke and
that the 1.64 stable release will not encounter any other surprises related to
the aforementioned change to the const-eval machinery.&lt;/p&gt;
&lt;p&gt;But fluke or not, the issue provided excellent motivation to spend some time
exploring facets of Rust&#x27;s const-eval architecture and the interpreter
that underlies it.
We hope you enjoyed reading this as much as we did writing it.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
</feed>
