<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2021-10-21T14:59:10+00:00</updated>

    
    <entry>
        <title>1.56.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/10/18/1.56.0-prerelease.html" type="text/html" title="1.56.0 pre-release testing" />
        <published>2021-10-18T00:00:00+00:00</published>
        <updated>2021-10-18T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/10/18/1.56.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/10/18/1.56.0-prerelease.html">&lt;p&gt;The 1.56.0 pre-release is ready for testing. The release is scheduled for this
Thursday, October 21st. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1560-2021-10-21&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2021-10-18/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2021-10-18/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-56-0-pre-release-testing/15459&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team October update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/10/08/Lang-team-Oct-update.html" type="text/html" title="Lang team October update" />
        <published>2021-10-08T00:00:00+00:00</published>
        <updated>2021-10-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/10/08/Lang-team-Oct-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/10/08/Lang-team-Oct-update.html">&lt;p&gt;This week the lang team held its October planning meeting (&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-10-06-Planning-meeting.md&quot;&gt;minutes&lt;/a&gt;). We hold these meetings on the first Wednesday of every month.&lt;/p&gt;
&lt;p&gt;The planning meeting is used for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Checking in on the status of our &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/initiatives.html&quot;&gt;active initiatives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Planning the design meetings for the remainder of the month&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After each meeting, we post an update (like this one!) with notes and meeting announcements.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#update-from-active-initiatives&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;update-from-active-initiatives&quot;&gt;&lt;/a&gt;Update from active initiatives&lt;/h2&gt;
&lt;p&gt;What follows are the updates that were submitted this month. Note that many of the more recent initiatives have dedicated repositories which contain other byproducts of the design process (e.g., evaluation documents, open design questions, etc). Take a look!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/updates/2021-oct.html&quot;&gt;Async fundamentals update&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; Async fn in traits, async drop, async closures&lt;/li&gt;
&lt;li&gt;Have designated an &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/roadmap/mvp.html&quot;&gt;MVP&lt;/a&gt; version of async functions in traits that we intend to stabilize first, and done a lot of exploration on next steps (read up on that in the ever evolving &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation.html&quot;&gt;evaluation doc&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/impl-trait-initiative/updates/2021-oct.html&quot;&gt;Impl trait initiative update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; &lt;code&gt;type Foo &#x3D; impl Trait&lt;/code&gt; at the module and impl level.&lt;/li&gt;
&lt;li&gt;oli-obk has completed a rewrite of the inference engine to better match the design proposed the RFC, and it is slowly being merged in&lt;/li&gt;
&lt;li&gt;We are working on explainer plus stabilization doc to &amp;quot;Type alias impl trait&amp;quot;.&lt;/li&gt;
&lt;li&gt;We would like to add syntax to give names for function types, which unblocks &amp;quot;impl trait in traits&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/dyn-upcasting-coercion-initiative/updates/2021-oct.html&quot;&gt;Dyn upcasting initiative update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; Ability to cast &lt;code&gt;dyn Foo&lt;/code&gt; to &lt;code&gt;dyn Bar&lt;/code&gt; if &lt;code&gt;trait Foo: Bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Made good progress, need to resolve a soundness question and then ready to merge.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/generic-associated-types-initiative/updates/2021-oct.html&quot;&gt;Generic associated type initiative update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; Ability to have associated types with generic parameters, such as &lt;code&gt;type Foo&amp;lt;&#x27;me&amp;gt;&lt;/code&gt;, in traits.&lt;/li&gt;
&lt;li&gt;Resolved the question of where clause defaults by deciding on a conservative, if not maximally ergonomic, path.&lt;/li&gt;
&lt;li&gt;Making continued progress towards something we can stabilize. The intent is to start with some known ergonomic shortcomings and build from there.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/87335#issuecomment-933672440&quot;&gt;Let else update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; Generalization of &lt;code&gt;let&lt;/code&gt; to permit you to match against something and panic, return, etc when match fails:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let Ok(x) &#x3D; something else panic!()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation available on nightly, may be feature complete&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/88#issuecomment-935056996&quot;&gt;Deref patterns update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; Applying Deref impls in the context of a match, such as &lt;code&gt;match rc { Some(x) &#x3D;&amp;gt; ..., None &#x3D;&amp;gt; ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Decided to build prototype that does not have any explicit syntax for deref and works against &amp;quot;known safe&amp;quot; std types.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/60#issuecomment-935233842&quot;&gt;Never type stabilization update&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What is it?&lt;/strong&gt; The never type &lt;code&gt;!&lt;/code&gt;&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;We have landed an improved, if complex, analysis that allows us to choose between the current behavior (fallback to &lt;code&gt;()&lt;/code&gt;) and the new behavior (fallback to &lt;code&gt;!&lt;/code&gt;) without breaking important existing code. The hope is to proceed with stabilization and slowly improve and simplify the rules using warnings, editions, or other tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition to the reports above, you&#x27;ll find more detailed discussing in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-10-06-Planning-meeting.md&quot;&gt;minutes&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#upcoming-design-meetings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;upcoming-design-meetings&quot;&gt;&lt;/a&gt;Upcoming design meetings&lt;/h2&gt;
&lt;p&gt;We have planned the following design meetings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;October 13: Syntax for where clauses in GATs and type aliases (&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/120&quot;&gt;lang-team#120&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;October 20: Safety considerations for dyn upcasting (&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/119&quot;&gt;lang-team#119&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;October 27: Forbidding unwinding from drop impls (&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/97&quot;&gt;lang-team#97&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#design-meeting-expectations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;design-meeting-expectations&quot;&gt;&lt;/a&gt;Design meeting expectations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The document for the meeting must be prepared by the triage meeting on Tuesday and posted to the tracking issue.
&lt;ul&gt;
&lt;li&gt;If it is not sent out by then, the meeting will be canceled. This gives folks 24 hour notice.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;There is no expectation that people will read the document before the meeting. The meeting will begin with a recap of the document.
&lt;ul&gt;
&lt;li&gt;However, there is no rule &lt;strong&gt;against&lt;/strong&gt; reading the document beforehand and providing feedback or advice on how to improve it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;The never type is called never because it will &lt;em&gt;never&lt;/em&gt; be stabilized. Ha! I kill me. --nikomatsakis &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;â†©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>1.55.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/09/07/1.55.0-prerelease.html" type="text/html" title="1.55.0 pre-release testing" />
        <published>2021-09-07T00:00:00+00:00</published>
        <updated>2021-09-07T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/09/07/1.55.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/09/07/1.55.0-prerelease.html">&lt;p&gt;The 1.55.0 pre-release is ready for testing. The release is scheduled for this
Thursday, September 9th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1550-2021-09-09&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2021-09-06/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2021-09-06/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-55-0-pre-release-testing/15292&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>Splitting the const generics features</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/09/06/Splitting-const-generics.html" type="text/html" title="Splitting the const generics features" />
        <published>2021-09-06T00:00:00+00:00</published>
        <updated>2021-09-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/09/06/Splitting-const-generics.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/09/06/Splitting-const-generics.html">&lt;p&gt;After the stabilization of the const generics MVP in version 1.51, the const generics project group has continued to
work on const generics. Large parts of this work were gated behind the feature gates &lt;code&gt;const_generics&lt;/code&gt; and &lt;code&gt;const_evaluatable_checked&lt;/code&gt;. As time went on, the
&lt;code&gt;const_generics&lt;/code&gt; feature became fairly useless on its own while the name of
&lt;code&gt;const_evaluatable_checked&lt;/code&gt; didn&#x27;t really capture what this feature was intended to do.&lt;/p&gt;
&lt;p&gt;To improve this, we have recently removed the features &lt;code&gt;const_generics&lt;/code&gt;, &lt;code&gt;lazy_normalization_consts&lt;/code&gt;, and &lt;code&gt;const_evaluatable_checked&lt;/code&gt;. They have been replaced by &lt;code&gt;feature(adt_const_params)&lt;/code&gt; and &lt;code&gt;feature(generic_const_exprs)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As there is a lot going on with const generics, here&#x27;s a quick overview of the new - and preexisting - features and how much still needs to be done for them to get stabilized:&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#featureadt_const_params&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;featureadt_const_params&quot;&gt;&lt;/a&gt;&lt;code&gt;feature(adt_const_params)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;On stable, only integers, &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; are allowed as the types of const parameters. This feature allows additional types, such as &lt;code&gt;&amp;amp;&#x27;static str&lt;/code&gt; and user defined types.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(adt_const_params)]

#[derive(PartialEq, Eq)]
enum ImageFormat {
    Rgb8,
    Rgba8,
    // ...c
}

struct Image&amp;lt;const FORMAT: ImageFormat&amp;gt; {
    // ...
}

impl Image&amp;lt;{ ImageFormat::Rgba }&amp;gt; {
    fn alpha(&amp;amp;self, pixel: PixelLocation) -&amp;gt; u8 {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that even with this feature, generic const parameter types, such as &lt;code&gt;struct Foo&amp;lt;T, const N: T&amp;gt; { ... }&lt;/code&gt;, are forbidden.
While allowing such things is desired, it adds additional complications exceeding our current capacity.&lt;/p&gt;
&lt;p&gt;There are still two major blockers for stabilization:&lt;/p&gt;
&lt;p&gt;The first being the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/83234&quot;&gt;transition to valtrees&lt;/a&gt;. Valtrees are a representation of values as trees with integer nodes, simplifiying the way we interact with more complex types.&lt;/p&gt;
&lt;p&gt;Additionally, we have to figure out which types we &lt;em&gt;even want&lt;/em&gt; to allow as const parameter types. This ties into the discussion
about &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/74446&quot;&gt;&amp;quot;structural match&amp;quot;&lt;/a&gt;, which is still ongoing.&lt;/p&gt;
&lt;p&gt;While the issues mentioned above are definitely not trivial, it is definitely possible for this to be ready for stabilization in a few months.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#featuregeneric_const_exprs&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;featuregeneric_const_exprs&quot;&gt;&lt;/a&gt;&lt;code&gt;feature(generic_const_exprs)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Without any unstable features, const arguments must either be a fully concrete expression or a generic parameter by itself, so constants like &lt;code&gt;N + 1&lt;/code&gt; are forbidden. With this feature, expressions using generic parameters are possible.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(generic_const_exprs)]

fn split_first&amp;lt;T, const N: usize&amp;gt;(arr: [T; N]) -&amp;gt; (T, [T; N - 1]) {
    // ...
}

struct BitSet&amp;lt;const SIZE: usize&amp;gt;
where
    [u8; (SIZE + 7) / 8]: Sized,
{
    storage: [u8; (SIZE + 7) / 8],
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We currently require the user to add bounds asserting that generic constants evaluate successfully. For all constants visible in the API of an item, these bounds are added implicitly.&lt;/p&gt;
&lt;p&gt;If the constant expression &lt;code&gt;expr&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; would otherwise not be used in the &lt;code&gt;where&lt;/code&gt;-clauses or function signature, we add an otherwise irrelevant bound mentioning &lt;code&gt;expr&lt;/code&gt; to the &lt;code&gt;where&lt;/code&gt;-clauses of our item. For this one can define a &lt;code&gt;struct Evaluatable&amp;lt;const N: Foo&amp;gt;;&lt;/code&gt; and use &lt;code&gt;Evaluatable&amp;lt;{ expr }&amp;gt;:&lt;/code&gt; as a bound. If &lt;code&gt;expr&lt;/code&gt; is of type &lt;code&gt;usize&lt;/code&gt; we tend to use &lt;code&gt;[u8; expr]:&lt;/code&gt;
or &lt;code&gt;[u8; expr]: Sized&lt;/code&gt; for this. While it is highly likely that we will add a dedicated syntax for these bounds in the future, we are waiting with this until the rest of this feature is more mature.&lt;/p&gt;
&lt;p&gt;This feature is still far from being stable and has some &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-const-generics/blob/master/design-docs/anon-const-substs.md&quot;&gt;&lt;strong&gt;major&lt;/strong&gt; unsolved issues&lt;/a&gt;. Especially for constants inside of &lt;code&gt;where&lt;/code&gt;-bounds there are a lot of subtle bugs and backwards incompatibilities we have to fix before we can even think about how to stabilize this.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#featureconst_generics_defaults&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;featureconst_generics_defaults&quot;&gt;&lt;/a&gt;&lt;code&gt;feature(const_generics_defaults)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Similar to type parameter defaults, this feature adds the ability to declare default values for const parameters.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(const_generics_defaults)]

struct ArrayStorage&amp;lt;T, const N: usize &#x3D; 2&amp;gt; {
    arr: [T; N],
}

impl&amp;lt;T&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
    fn new(a: T, b: T) -&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
        ArrayStorage {
            arr: [a, b],
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To allow type parameter defaults in the same listing as const parameters we also intend to remove the ordering restriction for
type and const parameters, allowing &lt;code&gt;struct Foo&amp;lt;const N: usize, T &#x3D; [u32; N]&amp;gt; { ... }&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This feature is pretty much ready for stabilization and is currently blocked on figuring out any potential edge cases for the
stabilization report.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#featuregeneric_arg_infer&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;featuregeneric_arg_infer&quot;&gt;&lt;/a&gt;&lt;code&gt;feature(generic_arg_infer)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;While it is already possible to use a wildcard &lt;code&gt;_&lt;/code&gt; for type arguments inside of bodies, this is not the case for const arguments.
This feature adds this capability for constants.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(generic_arg_infer)]
fn array_from&amp;lt;T, U, const N: usize&amp;gt;(arr: [T; N]) -&amp;gt; [U; N]
where
    U: From&amp;lt;T&amp;gt;,
{
    arr.map(From::from)
}

fn main() {
    let x &#x3D; [&amp;quot;this&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;six&amp;quot;, &amp;quot;element&amp;quot;, &amp;quot;array&amp;quot;];
    // using &#x60;_&#x60; for the parameter &#x60;N&#x60; lets
    // the compiler infer the correct value
    let _y &#x3D; array_from::&amp;lt;_, String, _&amp;gt;(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature is not yet ready for stabilization, though there aren&#x27;t any known big blockers here.
To confidently stabilize this we are probably in need of some large refactorings though, as the current setup
feels fairly fragile in some areas.&lt;/p&gt;
</content>

        <author>
            <name>lcnr</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team August update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/08/04/lang-team-aug-update.html" type="text/html" title="Lang team August update" />
        <published>2021-08-04T00:00:00+00:00</published>
        <updated>2021-08-04T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/08/04/lang-team-aug-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/08/04/lang-team-aug-update.html">&lt;p&gt;This week the lang team held its August planning meeting. We normally hold
these meetings on the first Wednesday of every month.&lt;/p&gt;
&lt;p&gt;We had a short meeting this month, just planning and scheduling the design
meetings for the remainder of the month.&lt;/p&gt;
&lt;p&gt;After each meeting, we post an update (like this one!) with notes and meeting announcements.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#upcoming-design-meetings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;upcoming-design-meetings&quot;&gt;&lt;/a&gt;Upcoming design meetings&lt;/h2&gt;
&lt;p&gt;We planned two design meetings for August. Our meetings are open for anyone to join and observe. Ping nikomatsakis or joshtriplett for info about attending.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2021-08-11: No meeting this week&lt;/li&gt;
&lt;li&gt;2021-08-18: &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/94&quot;&gt;Structural equality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2021-08-25: &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/111&quot;&gt;Non-terminal divergence between parser and macro matcher&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#design-meeting-expectations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;design-meeting-expectations&quot;&gt;&lt;/a&gt;Design meeting expectations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The document for the meeting must be prepared by the triage meeting on Tuesday and posted to the tracking issue.
&lt;ul&gt;
&lt;li&gt;If it is not sent out by then, the meeting will be canceled. This gives folks 24-hour notice.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;There is no expectation that people will read the document before the meeting. The meeting will begin with a recap of the document.
&lt;ul&gt;
&lt;li&gt;However, there is no rule &lt;strong&gt;against&lt;/strong&gt; reading the document beforehand and providing feedback or advice on how to improve it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler August Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/07/30/compiler-team-august-steering-cycle.html" type="text/html" title="Rust Compiler August Steering Cycle" />
        <published>2021-07-30T00:00:00+00:00</published>
        <updated>2021-07-30T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/07/30/compiler-team-august-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/07/30/compiler-team-august-steering-cycle.html">&lt;p&gt;n &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/86722planningmeeting20210730.html&quot;&gt;Friday, July 30th&lt;/a&gt;, the Rust Compiler team had a planning meeting for the August steering cycle.&lt;/p&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/446&quot;&gt;Friday, 20 August&lt;/a&gt;, we will be having a meeting to
discuss how to increase the number of reviewers available to handle the review queue load.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>1.54.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/07/26/1.54.0-prerelease.html" type="text/html" title="1.54.0 pre-release testing" />
        <published>2021-07-26T00:00:00+00:00</published>
        <updated>2021-07-26T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/07/26/1.54.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/07/26/1.54.0-prerelease.html">&lt;p&gt;The 1.54.0 pre-release is ready for testing. The release is scheduled for this
Thursday, July 29th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1540-2021-07-29&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2021-07-26/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2021-07-26/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/1-54-0-pre-release-testing/15087&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler July Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/07/02/compiler-team-july-steering-cycle.html" type="text/html" title="Rust Compiler July Steering Cycle" />
        <published>2021-07-02T00:00:00+00:00</published>
        <updated>2021-07-02T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/07/02/compiler-team-july-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/07/02/compiler-team-july-steering-cycle.html">&lt;p&gt;n &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/74498steeringmeeting20210702fingerprintsplanning.html&quot;&gt;Friday, July 2nd&lt;/a&gt;, the Rust Compiler team had a planning meeting for the July steering cycle, followed by a continuation of an ongoing discussion of the 1.52.0 fingerprint event.&lt;/p&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/435&quot;&gt;Friday, 9 July&lt;/a&gt;, we will be having a third follow-up meeting to
continue the discussion of the incremental compilation fingerprint issue that
led to the emergency 1.52.1 release. For reference, the first meeting on this
subject was held on &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/56399steeringmeeting20210625152retrocompilerteam435.html&quot;&gt;Friday, 25 June&lt;/a&gt; (and the second was
today, &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/74498steeringmeeting20210702fingerprintsplanning.html&quot;&gt;July 2nd&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;On &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/444&quot;&gt;Friday, 16 July&lt;/a&gt;, we will be having a meeting to discuss
extensions to the review policy for Rust Compiler Pull Requests.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>What the Error Handling Project Group is Working Towards</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html" type="text/html" title="What the Error Handling Project Group is Working Towards" />
        <published>2021-07-01T00:00:00+00:00</published>
        <updated>2021-07-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html">&lt;p&gt;This blog post is a follow up of our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2020/11/23/What-the-error-handling-project-group-is-working-on.html&quot;&gt;previous&lt;/a&gt; post detailing what we&#x27;re working on now. We&#x27;ve been iterating for a while now on some of the challenges that we see with error handling today and have reached the point where we want to describe some of the new changes we&#x27;re working towards. But first we need to describe the main challenges we&#x27;ve identified.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Disclaimer: &lt;em&gt;This post is equal parts plan and aspiration. There are technical challenges here to sort out so the final outcome may look rather different from our initial vision, so please don&#x27;t assume any of this is final.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#error-handling-today&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;error-handling-today&quot;&gt;&lt;/a&gt;Error Handling Today&lt;/h2&gt;
&lt;p&gt;The first challenge we&#x27;d like to solve is that it&#x27;s easy to lose context accidentally when reporting errors. There are a couple of places this can happen, either when printing an error and forgetting to print sources, when returning an error from main, or when converting a recoverable error into a non recoverable error.&lt;/p&gt;
&lt;p&gt;Consider this example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::fmt;

// We have a program that loads a config and expects that
// loading the config will always succeed.
fn main() {
    let _config &#x3D; load_config()
        .expect(&amp;quot;config is always valid and exists&amp;quot;);
}

// We have a dummy implementation of load_config which
// always errors, since we&#x27;re just focusing on diagnostics
// here.
fn load_config() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
    Err(Error(SourceError))
}

// And we have an error type that just prints &amp;quot;invalid
// config&amp;quot; and has a source error which just prints &amp;quot;config
// file does not exist&amp;quot;
#[derive(Debug)]
struct Error(SourceError);

impl fmt::Display for Error {
    fn fmt(&amp;amp;self, f: &amp;amp;mut fmt::Formatter&amp;lt;&#x27;_&amp;gt;) -&amp;gt; fmt::Result {
        f.write_str(&amp;quot;invalid config&amp;quot;)
    }
}

impl std::error::Error for Error {
    fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn std::error::Error + &#x27;static)&amp;gt; {
        Some(&amp;amp;self.0)
    }
}

#[derive(Debug)]
struct SourceError;

impl fmt::Display for SourceError {
    fn fmt(&amp;amp;self, f: &amp;amp;mut fmt::Formatter&amp;lt;&#x27;_&amp;gt;) -&amp;gt; fmt::Result {
        f.write_str(&amp;quot;config file does not exist&amp;quot;)
    }
}

impl std::error::Error for SourceError {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run this we would like to see output somewhat like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
thread &#x27;main&#x27; panicked at &#x27;config is always valid and exists&#x27;, src/main.rs:4:33

Error:
    0: invalid config
    1: config file does not exist

note: run with &#x60;RUST_BACKTRACE&#x3D;1&#x60; environment variable to display a backtrace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this error message we can see that we exited because of a panic. We can see what invariant we violated that was supposed to prevent this panic from happening. We can see the location where the panic was produced. And we can see the error message of each error in the chain of errors accessible via &lt;code&gt;source&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That&#x27;s what we would like, at least in the version of Rust that the error handling project group wants to see, but what we actually get is this...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
thread &#x27;main&#x27; panicked at &#x27;config is always valid and exists: Error(SourceError)&#x27;, main.rs:4:33
note: run with &#x60;RUST_BACKTRACE&#x3D;1&#x60; environment variable to display a backtrace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, I definitely don&#x27;t think this is what we want as a default when promoting recoverable errors to non-recoverable errors! &lt;code&gt;unwrap&lt;/code&gt; and &lt;code&gt;expect&lt;/code&gt; work by stringifying the error variant using its &lt;code&gt;Debug&lt;/code&gt; impl, but this is often the wrong operation for types that implement the &lt;code&gt;Error&lt;/code&gt; trait. By converting the &lt;code&gt;Error&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; we lose access to the pieces of context we carefully split up via the &lt;code&gt;Error&lt;/code&gt; trait, and in all likelihood the &lt;code&gt;derive(Debug)&lt;/code&gt; output of our error types won&#x27;t even include the error messages in our &lt;code&gt;Display&lt;/code&gt; impls.&lt;/p&gt;
&lt;p&gt;Rust&#x27;s panic infrastructure doesn&#x27;t provide a method for converting an &lt;code&gt;Error&lt;/code&gt; type into a panic, it only supports converting &lt;code&gt;Debug&lt;/code&gt; types into panics, and we feel that this is a major issue. Similarly, there&#x27;s no convenient tools provided by the language for printing an error and all of its source&#x27;s error messages.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn main() {
    let result &#x3D; load_config();
    let _config &#x3D; match result {
        Ok(config) &#x3D;&amp;gt; config,
        Err(error) &#x3D;&amp;gt; {
            println!(&amp;quot;Error: {}&amp;quot;, error);
            return;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run this program we&#x27;d like to see output that looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
Error: invalid config: config file does not exist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can see the header we provided to indicate we&#x27;re printing an error, followed by each error message in the chain of sources separated by colons.&lt;/p&gt;
&lt;p&gt;But instead all we get is this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
Error: invalid config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default all of the source&#x27;s error messages are lost. This arises from the fact that we used &lt;code&gt;Display&lt;/code&gt; as the interface to an individual error message. If we could go back we&#x27;d currently propose instead adding &lt;code&gt;fn message(&amp;amp;self, f: &amp;amp;mut fmt::Formatter&amp;lt;&#x27;_&amp;gt;) -&amp;gt; fmt::Result&lt;/code&gt; to the &lt;code&gt;Error&lt;/code&gt; trait, but that ship has sailed.&lt;/p&gt;
&lt;p&gt;The way that libraries work around this today is by abusing the &lt;code&gt;Debug&lt;/code&gt; trait. Types like &lt;a href&#x3D;&quot;https://docs.rs/eyre/0.6.5/eyre/trait.EyreHandler.html#tymethod.debug&quot;&gt;&lt;code&gt;eyre&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://docs.rs/anyhow/1.0.40/src/anyhow/fmt.rs.html#19&quot;&gt;&lt;code&gt;anyhow&lt;/code&gt;&lt;/a&gt;, and even sometimes &lt;a href&#x3D;&quot;https://www.lpalmieri.com/posts/error-handling-rust/#error_chain_fmt&quot;&gt;&lt;code&gt;custom error enums&lt;/code&gt;&lt;/a&gt; use their &lt;code&gt;Debug&lt;/code&gt; output to print the full chain of errors in a human readable report.&lt;/p&gt;
&lt;p&gt;This has the advantage of making it easy to print a full error report and makes it so &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, and return from main all print the full error report. But doing so prevents us from accessing the derived &lt;code&gt;Debug&lt;/code&gt; format of our errors, potentially hiding internal details that might be needed for debugging but which aren&#x27;t part of the error messages intended for users to read.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#error-handling-tomorrow&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;error-handling-tomorrow&quot;&gt;&lt;/a&gt;Error Handling Tomorrow&lt;/h2&gt;
&lt;p&gt;Eventually we&#x27;d like to get to a place where the default tools you reach for when error handling in Rust all do the right thing and fully leverage the &lt;code&gt;Error&lt;/code&gt; trait&#x27;s design. Unwrapping a type that implements the &lt;code&gt;Error&lt;/code&gt; trait will preserve the original error as a &lt;code&gt;dyn Error&lt;/code&gt; which is then available in the panic hook. Printing a full error report will be easy to do and obvious. With these changes in place it will hopefully be quite difficult to accidentally discard information when reporting errors.&lt;/p&gt;
&lt;p&gt;Our plan to fix these issues is two-fold:&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#1-error-trait--panic-runtime-integration&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;1-error-trait--panic-runtime-integration&quot;&gt;&lt;/a&gt;1. Error Trait + Panic Runtime Integration&lt;/h3&gt;
&lt;p&gt;First we need to integrate the Error trait and the panic runtime, and the first step to doing so will be moving the &lt;code&gt;Error&lt;/code&gt; trait into &lt;code&gt;core&lt;/code&gt;. This is necessary because the panic runtime is part of &lt;code&gt;core&lt;/code&gt; and the language itself, where as the &lt;code&gt;Error&lt;/code&gt; trait currently resides in &lt;code&gt;std&lt;/code&gt;. We&#x27;re pretty excited about this change which we hope will have other positive downstream effects, particularly in the embedded ecosystem.&lt;/p&gt;
&lt;p&gt;Once we&#x27;ve gotten to the point where the &lt;code&gt;Error&lt;/code&gt; trait is usable in &lt;code&gt;core&lt;/code&gt; APIs the next step will be to add an interface for creating a panic from an &lt;code&gt;Error&lt;/code&gt; type. We&#x27;re currently planning on adding a &lt;code&gt;panic_error&lt;/code&gt; function, similar to the &lt;code&gt;panic_any&lt;/code&gt; function that is already available in &lt;code&gt;std&lt;/code&gt;. This function will give the panic handler access to errors via a &lt;code&gt;dyn Error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once panic handlers are able to process &lt;code&gt;Error&lt;/code&gt; types the next step will be to update the default panic hook provided by &lt;code&gt;std&lt;/code&gt; to actually report panics via the &lt;code&gt;Error&lt;/code&gt; trait if they&#x27;re exposed as such. It should iterate over sources and print the backtrace captured by the error itself if one is available, or possibly capture one itself otherwise.&lt;/p&gt;
&lt;p&gt;Finally, we need to specialize &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;unwrap&lt;/code&gt; to use these new &lt;code&gt;Error&lt;/code&gt; aware panic interfaces when unwrapping types that implement the &lt;code&gt;Error&lt;/code&gt; trait. To do this we first need to work around a &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/#the-soundness-problem&quot;&gt;soundness issue&lt;/a&gt; with specialization for trait impls that are conditional based on lifetimes, though thankfully we already have a good idea of &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls&quot;&gt;how to fix this&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#2-error-reporter&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;2-error-reporter&quot;&gt;&lt;/a&gt;2. Error Reporter&lt;/h3&gt;
&lt;p&gt;We would also like to provide a basic error reporter in &lt;code&gt;std&lt;/code&gt;, and some facilities for making it easy to use, or easy to replace with your own preferred error reporter. Printing an error and its sources is a fundamental operation in Rust, so we want the language to provide a pit of success for reporting, where the easiest thing to do is the right thing. We can&#x27;t get there completely because we use &lt;code&gt;Display&lt;/code&gt; for individual error messages, and we can&#x27;t change that in a backwards compatible fashion, but we hope that adding a convenient method for printing a full chain of errors and some clever lints will relieve most of the pressure.&lt;/p&gt;
&lt;p&gt;We plan on fixing this by first adding a &lt;code&gt;Report&lt;/code&gt; type to the standard library that wraps a &lt;code&gt;&amp;amp;dyn Error&lt;/code&gt; and implements &lt;code&gt;Display&lt;/code&gt; such that it prints each source as desired. We would like the output of &lt;code&gt;Report&lt;/code&gt;&#x27;s display method to support the styles of error concatenation that are most common in the Rust ecosystem.&lt;/p&gt;
&lt;p&gt;Either one line with each error message concatenated with colons:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Error: {}&amp;quot;, Report::from(error));

// Outputs:
// Error: outermost error: second error: root error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or multiple lines with each error message on its own line :&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Error: {:#}&amp;quot;, Report::from(error))

// Outputs:
// Error: outermost error
//
// Caused by:
//    0: second error
//    1: root error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first single line format is useful for log output or inlined error messages, whereas the alternate multi line format is useful for user facing output such as a CLI interface or a GUI popup.&lt;/p&gt;
&lt;p&gt;We also want to add a method to the error trait for conveniently wrapping up any error in the &lt;code&gt;Report&lt;/code&gt; type so that reporting an error is as simple as &lt;code&gt;println!(&amp;quot;Error: {}&amp;quot;, error.report());&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We expect the report method will look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn report(&amp;amp;self) -&amp;gt; impl Display + &#x27;_
where
    Self: Sized,
{
    Report::from(self)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want the return type here to be generic rather than hard coded to &lt;code&gt;Report&lt;/code&gt; so that individual error types can provide their own report format if desired. We expect that derive macros may leverage this to customize error reporting format defaults. This will work well with composition because the reporter from the outermost type will be used to format the full chain of errors.&lt;/p&gt;
&lt;p&gt;For now we can&#x27;t implement this method as described because &lt;code&gt;impl Trait&lt;/code&gt; isn&#x27;t allowed in return types on trait methods, but we&#x27;re working to find a way to add this to the error trait backwards compatibly.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#duplicate-information-issue&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;duplicate-information-issue&quot;&gt;&lt;/a&gt;Duplicate Information Issue&lt;/h2&gt;
&lt;p&gt;With these fixes in place it will become easy to chain errors and report them completely and consistently. However there is a hazard that &lt;code&gt;Error&lt;/code&gt; implementors need to be aware of in this system: duplicate information.&lt;/p&gt;
&lt;p&gt;Imagine an error like the one in the previous example, except instead of each error printing its own message and returning the next error via &lt;code&gt;source&lt;/code&gt;, they also include their source&#x27;s error message after their own. That way when we print the outer error&#x27;s &lt;code&gt;Display&lt;/code&gt; output we see all of the error messages, not just the first in the chain.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Error: {}&amp;quot;, error);

// Outputs:
// Error: outermost error: second error: root error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, what happens we then print this same error type with &lt;code&gt;Report&lt;/code&gt; expecting that we need to iterate over the sources and print them too?&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Error: {:#}&amp;quot;, error.report());

// Outputs
// Error: outermost error: second error: root error
//
// Caused by:
//    0: second error: root error
//    1: root error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The source error messages get duplicated! With the multi-line output of &lt;code&gt;anyhow&lt;/code&gt; and &lt;code&gt;eyre&lt;/code&gt; we get this nice little triangle shape to the error report, which you&#x27;ve probably encountered if you&#x27;ve ever used these libraries before. We can no longer separate the error messages of the individual errors in the chain of errors because this error type concatenates the sources manually and returns them via the &lt;code&gt;source&lt;/code&gt; function. This also restricts how we can format our error reports. If we want a consistent report format and we have a dependency that concatenates errors in a single line we are forced to do so as well ourselves throughout our entire application. If, on the other hand, we have two dependencies that concatenate errors in different ways, well, we&#x27;re out of luck.&lt;/p&gt;
&lt;p&gt;So how do we avoid this? We adopt a consistent separation for &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; implementations.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#guidelines-for-implementing-displayfmt-and-errorsource&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;guidelines-for-implementing-displayfmt-and-errorsource&quot;&gt;&lt;/a&gt;Guidelines for implementing &lt;code&gt;Display::fmt&lt;/code&gt; and &lt;code&gt;Error::source&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;To resolve this issue, project error handling recently created a guideline for &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/issues/27#issuecomment-763950178&quot;&gt;how to implement &lt;code&gt;Display::fmt&lt;/code&gt; and &lt;code&gt;Error::source&lt;/code&gt;&lt;/a&gt;. In it we make the following recommendation:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An error type with a source error should either return that error via &lt;code&gt;source&lt;/code&gt; or include that source&#x27;s error message in its own &lt;code&gt;Display&lt;/code&gt; output, but never both.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We figure the default will be to return errors via source. That way source errors can be reacted to via &lt;code&gt;downcast&lt;/code&gt; when appropriate. This is particularly important for libraries that are changing existing public error types. For these libraries removing an error from &lt;code&gt;source&lt;/code&gt; is a breaking change that isn&#x27;t detected at compile time, making a major version bump likely insufficient. Changing the &lt;code&gt;Display&lt;/code&gt; output is also a breaking change, though a less dangerous one. To help with this we&#x27;ve drafted a suggested migration plan: &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/issues/44&quot;&gt;rust-lang/project-error-handling#44&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In coming up with this recommendation we had to figure out what the &lt;code&gt;Error&lt;/code&gt; trait&#x27;s primary role is in Rust. After discussing it with the library team we concluded that reporting should be treated as the primary role, and that reacting via &lt;code&gt;downcast&lt;/code&gt; should come second when designing error types. Generally these needs are not in conflict, but it is possible for issues to come up. For example, when working with transparent error types that forward all methods to an inner error type. When these types follow this guideline the inner error type is skipped over and is never made available for &lt;code&gt;downcast&lt;/code&gt;ing.&lt;/p&gt;
&lt;p&gt;This recommendation only applies for error types that are exposed as part of library APIs. Internal errors in libraries or and applications can do whatever they want, but as soon as they need to be integrated into other crates by 3rd party users it&#x27;s important that errors follow a consistent style. If you&#x27;re interested in our rationale or have any comments please check out our github issue on the topic: &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/issues/27&quot;&gt;rust-lang/project-error-handling#27&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We hope that these changes will significantly improve error handling experience provided by Rust. Error reporting will be more consistent and flexible and let the final application developer define how to format error reports for their specific use-case. It will be a lot harder to accidentally lose information when reporting errors. The tools for reporting errors will be more tightly integrated into the standard library and the language itself and we hope this will have extra benefits to the embedded ecosystem by more universally standardizing on the &lt;code&gt;Error&lt;/code&gt; trait.&lt;/p&gt;
&lt;p&gt;So that&#x27;s the plan for now, it&#x27;s not the full plan of all the changes we&#x27;d like to make, but we think its the best first step. However, this is by no means set in stone and we&#x27;re interested in getting feedback from the rest of the community so we can refine our design. So if you have thoughts please let us know, our project group repo is https://github.com/rust-lang/project-error-handling. Please feel free to &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/issues&quot;&gt;open an issue&lt;/a&gt; or hop in our &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling&quot;&gt;zulip stream&lt;/a&gt; and create a new topic to let us know what you think of this plan.&lt;/p&gt;
</content>

        <author>
            <name>Jane Lusby</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler June Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/06/23/compiler-team-june-steering-cycle.html" type="text/html" title="Rust Compiler June Steering Cycle" />
        <published>2021-06-23T00:00:00+00:00</published>
        <updated>2021-06-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/06/23/compiler-team-june-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/06/23/compiler-team-june-steering-cycle.html">&lt;p&gt;On &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/93506planningmeeting20210604.html&quot;&gt;Friday, June 4th&lt;/a&gt;, the Rust Compiler team had a planning meeting for the June steering cycle.&lt;/p&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/435&quot;&gt;Friday, 25 June&lt;/a&gt;, we will be having a meeting to review a
document discussing the incremental compilation fingerprint issue that led to
the emergency 1.52.1 release, and the steps the project is taking to prevent
future occurrences of similar scenarios. (This date is a change in schedule from
its original date that had been discussed in the planning meeting.)&lt;/p&gt;
&lt;p&gt;The meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
</feed>
